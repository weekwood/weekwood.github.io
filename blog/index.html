
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Di Wu's blog</title>
  <meta name="author" content="Di Wu">

   
  <meta name="description" content="">
  
  <meta name="keywords" content="">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://weekwood.github.com/blog">
  <link href="/favicon.png" rel="icon">
  <link href='http://fonts.googleapis.com/css?family=Quicksand:300,400' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300' rel='stylesheet' type='text/css'>
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Di Wu's blog" type="application/atom+xml">
  <script src="/js/jquery.js"></script>
  <script src="/js/bootstrap-collapse.js"></script>
  <script src="/js/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37603225-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <div class="navbar navbar-inverse navbar-static-top">
  	<div class="navbar-inner">
  	  <div class="container">
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".navbar-responsive-collapse">
          <span class="fui-menu-24"></span>
        </a>
  	  	<div class="nav-collapse collapse navbar-responsive-collapse" style="height:0;">
  	      <ul class="nav">
    
        <li ><a href="/index.html">Home</a></li>
    
        <li ><a href="/archives/index.html">Archives</a></li>
    
        <li ><a href="/about/index.html">About</a></li>
    
</ul>

<ul class="nav pull-right">
    
    <li><a href="http://github.com/weekwood" title="Github Profile"><i class="icon-github-sign social-navbar"></i></a></li>
    
    
    
    <li><a href="http://twitter.com/Dean_Woo" title="Twitter Profile"><i class="icon-twitter-sign social-navbar"></i></a></li>
    
    
    
    
</ul>

  	    </div>
  	  </div>
  	</div>
  </div>
  <div class="container" id="main">
    <div class="span12">
      <div class="row-fluid">
        <div id="content">
          


  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2014/07/02/issue-13-5-weekwood/">objc.io #issue 13 使用 VIPER 构建 iOS 应用</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2014-07-02T09:56:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Jul 2<span>nd</span>, 2014</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2014/07/02/issue-13-5-weekwood/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




  <p>建筑领域流行这样一句话，“我们虽然在营造建筑，但建筑也会重新塑造我们”。正如所有开发者最终领悟到的，这句话同样适用于构建软件。</p>

<p>编写代码中至关重要的是，需要使每一部分容易被识别，赋有一个特定而明显的目的，并与其他部分在逻辑关系中完美契合。这就是我们所说的软件架构。好的架构不仅让一个产品成功投入使用，还可以让产品具有可维护性，并让人不断头脑清醒的对它进行维护！</p>

<p>在这篇文章中，我们介绍了一种称之为 <a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/">VIPER</a> 的 iOS 应用架构的方式。VIPER 已经在很多大型的项目上成功实践，但是出于本文的目的我们将通过一个待办事项清单 (to-do app) 来介绍 VIPER 。你可以在 <a href="https://github.com/objcio/issue-13-viper">GitHub</a> 上关注这个项目。</p>

<p><video style="display:block;max-width:316px;height:auto;border:0;" poster="/issue-13/2014-06-07-viper-screenshot.png" controls="1">
  <source src="http://img.objccn.io//issue-13/2014-06-07-viper-preview.mp4"></source>
</video></p>

<h2>什么是 VIPER？</h2>

<p>测试永远不是构建 iOS 应用的主要部分。当我们 (<a href="https://github.com/mutualmobile/">Mutual Mobile</a>) 着手改善我们的测试实践时，我们发现给 iOS 应用写测试代码非常困难。因此如果想要设法改变测试的现状，我们首先需要一个更好的方式来架构应用，我们称之为 VIPER。</p>

<p>VIPER 是一个创建 iOS 应用<a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">简明构架</a>的程序。VIPER 可以是视图 (View)，交互器 (Interactor)，展示器 (Presenter)，实体 (Entity) 以及路由 (Routing) 的首字母缩写。简明架构将一个应用程序的逻辑结构划分为不同的责任层。这使得它更容易隔离依赖项 (如数据库)，也更容易测试各层间的边界处的交互：</p>

<p><img alt="VIPER stands for View Interactor Presenter Entity Routing." src="http://img.objccn.io/issue-13/2014-06-07-viper-intro.jpg"></p>

<p>大部分 iOS 应用利用 MVC 构建，使用 MVC 应用程序架构可以引导你将每一个类看做模型，视图或控制器中的一个。但由于大部分应用程序的逻辑不会存在于模型或视图中，所以通常最终总是在控制器里实现。这就导致一个称为<a href="https://twitter.com/Colin_Campbell/status/293167951132098560">重量级视图控制器</a>的问题，在这里，视图控制器做了太多工作。为这些重量级视图控制器<a href="http://www.objc.io/issue-1/lighter-view-controllers.html">瘦身</a>并不是 iOS 开发者寻求提高代码的质量所要面临的唯一挑战，但至少这是一个很好的开端。</p>

<p>VIPER 的不同层提供了明确的程序逻辑以及导航控制代码来应对这个挑战，利用 VIPER ，你会注意到在我们的待办事项示例清单中的视图控制器可以简洁高效，意义明确地控制视图。你也会发现视图控制器中代码和所有的其他类很容易理解，容易测试，理所当然也更易维护。</p>

<h2>基于用例的应用设计</h2>

<p>应用通常是一些用户用例的集合。用例也被称为验收标准，或行为集，它们用来描述应用的用途。清单可以根据时间，类型以及名字排序，这就是一个用例。用例是应用程序中用来负责业务逻辑的一层，应独立于用户界面的实现，同时要足够小，并且有良好的定义。决定如何将一个复杂的应用分解成较小的用例非常具有挑战性，并且需要长期实践，但这对于缩小你解决的问题时所要面临的范围及完成的每个类的所要涉及的内容来说，是很有帮助的。</p>

<p>利用 VIPER 建立一个应用需要实施一组套件来满足所有的用例，应用逻辑是实现用例的主要组成部分，但却不是唯一。用例也会影响用户界面。另一个重要的方面，是要考虑用例如何与其他应用程序的核心组件相互配合，例如网络和数据持久化。组件就好比用例的插件，VIPER 则用来描述这些组件的作用是什么，如何进行交互。</p>

<p>我们其中一个用例，或者说待办事项清单中其中的一个需求是可以基于用户的选择来将待办事项分组。通过分离的逻辑将数据组织成一个用例，我们能够在测试时使用户界面代码保持干净，用例更易组装，从而确保它如我们预期的方式工作。</p>

<h2>VIPER 的主要部分</h2>

<p>VIPER 的主要部分是：</p>

<ul>
<li>视图：根据展示器的要求显示界面，并将用户输入反馈给展示器。</li>
<li>交互器：包含由用例指定的业务逻辑。</li>
<li>展示器：包含为显示（从交互器接受的内容）做的准备工作的相关视图逻辑，并对用户输入进行反馈（从交互器获取新数据）。</li>
<li>实体：包含交互器要使用的基本模型对象。</li>
<li>路由：包含用来描述屏幕显示和显示顺序的导航逻辑。</li>
</ul>


<p>这种分隔形式同样遵循<a href="http://www.objectmentor.com/resources/articles/srp.pdf">单一责任原则</a>。交互器负责业务分析的部分，展示器代表交互设计师，而视图相当于视觉设计师。</p>

<p>以下则是不同组件的相关图解，并展示了他们之间是如何关联的：</p>

<p><img alt="VIPER breaks down an app into different components based around use cases, including components that create the user interface and the logic that powers it." src="http://img.objccn.io/issue-13/2014-06-07-viper-wireframe.png"></p>

<p>虽然在应用中 VIPER 的组件可以以任意顺序实现，我们在这里选择按照我们推荐的顺序来进行介绍。你会注意到这个顺序与构建整个应用的进程大致符合 &#8211; 首先要讨论的是产品需要做什么，以及用户会如何与之交互。</p>

<h3>交互器</h3>

<p>交互器在应用中代表着一个独立的用例。它具有业务逻辑以操纵模型对象（实体）执行特定的任务。交互器中的工作应当独立与任何用户界面，同样的交互器可以同时运用于 iOS 应用或者 OS X 应用中。</p>

<p>由于交互器是一个 PONSO (Plain Old <code>NSObject</code>，普通的 <code>NSObject</code>)，它主要包含了逻辑，因此很容易使用 TDD 进行开发。</p>

<p>示例应用的主要用例是向用户展示所有的待办事项（比如任何截止于下周末的任务）。此类用例的业务逻辑主要是找出今天至下周末之间将要到期的待办事项，然后为它们分配一个相对的截止日期，比如今天，明天，本周以内，或者下周。</p>

<p>以下是来自 VTDListInteractor 的对应方法：</p>

<pre><code>- (void)findUpcomingItems
{
    __weak typeof(self) welf = self;
    NSDate* today = [self.clock today];
    NSDate* endOfNextWeek = [[NSCalendar currentCalendar] dateForEndOfFollowingWeekWithDate:today];
    [self.dataManager todoItemsBetweenStartDate:today endDate:endOfNextWeek completionBlock:^(NSArray* todoItems) {
        [welf.output foundUpcomingItems:[welf upcomingItemsFromToDoItems:todoItems]];
    }];
}
</code></pre>

<h3>实体</h3>

<p>实体是被交互器操作的模型对象，并且它们只被交互器所操作。交互器永远不会传输实体至表现层 (比如说展示器)。</p>

<p>实体也应该是 PONSOs。如果你使用 Core Data，最好是将托管对象保持在你的数据层之后，交互器不应与 NSManageObjects 协同工作。</p>

<p>这里是我们的待办事项服务的实体：</p>

<pre><code>@interface VTDTodoItem : NSObject

@property (nonatomic, strong)   NSDate*     dueDate;
@property (nonatomic, copy)     NSString*   name;

+ (instancetype)todoItemWithDueDate:(NSDate*)dueDate name:(NSString*)name;

@end
</code></pre>

<p>不要诧异于你的实体仅仅是数据结构，任何依赖于应用的逻辑都应该放到交互器中。</p>

<h3>展示器</h3>

<p>展示器是一个主要包含了驱动用户界面的逻辑的 PONSO，它总是知道何时呈现用户界面。基于其收集来自用户交互的输入功能，它可以在合适的时候更新用户界面并向交互器发送请求。</p>

<p>当用户点击 “+” 键新建待办事项时，<code>addNewEntry</code> 被调用。对于此项操作，展示器会要求 <code>wireframe</code> 显示用户界面以增加新项目：</p>

<pre><code>- (void)addNewEntry
{
    [self.listWireframe presentAddInterface];
}
</code></pre>

<p>展示器还会从交互器接收结果并将结果转换成能够在视图中有效显示的形式。</p>

<p>下面是如何从交互器接受待办事项的过程，其中包含了处理数据的过程并决定展现给用户哪些内容：</p>

<pre><code>- (void)foundUpcomingItems:(NSArray*)upcomingItems
{
    if ([upcomingItems count] == 0)
    {
        [self.userInterface showNoContentMessage];
    }
    else
    {
        [self updateUserInterfaceWithUpcomingItems:upcomingItems];
    }
}
</code></pre>

<p>实体永远不会由交互器传输给展示器，取而代之，那些无行为的简单数据结构会从交互器传输到展示器那里。这就防止了那些“真正的工作”在展示器那里进行，展示器只能负责准备那些在视图里显示的数据。</p>

<h3>视图</h3>

<p>视图一般是被动的，它通常等待展示器下发需要显示的内容，而不会向其索取数据。视图（例如登录界面的登录视图控件）所定义的方法应该允许展示器在高度抽象的层次与之交流。展示器通过内容进行表达，而不关心那些内容所显示的样子。展示器不知道 <code>UILabel</code>，<code>UIButton</code> 等的存在，它只知道其中包含的内容以及何时需要显示。内容如何被显示是由视图来进行控制的。</p>

<p>视图是一个抽象的接口 (Interface)，在 Objective-C 中使用协议被定义。一个 <code>UIViewController</code> 或者它的一个子类会实现视图协议。比如我们的示例中 “添加” 界面会有以下接口：</p>

<pre><code>@protocol VTDAddViewInterface &lt;NSObject&gt;

- (void)setEntryName:(NSString *)name;
- (void)setEntryDueDate:(NSDate *)date;

@end
</code></pre>

<p>视图和视图控制器同样会操纵用户界面和相关输入。因为通常来说视图控制器是最容易处理这些输入和执行某些操作的地方，所以也就不难理解为什么视图控制器总是这么大了。为了使视图控制器保持苗条，我们需要使它们在用户进行相关操作的时候可以有途径来通知相关部分。视图控制器不应当根据这些行为进行相关决定，但是它应当将发生的事件传递到能够做决定的部分。</p>

<p>在我们的例子中，Add View Controller 有一个事件处理的属性，它实现了如下接口：</p>

<pre><code>@protocol VTDAddModuleInterface &lt;NSObject&gt;

- (void)cancelAddAction;
- (void)saveAddActionWithName:(NSString *)name dueDate:(NSDate *)dueDate

@end
</code></pre>

<p>当用户点击取消键的时候，视图控制器告知这个事件处理程序用户需要其取消这次添加的动作。这样一来，事件处理程序便可以处理关闭 add view controller 并告知列表视图进行更新。</p>

<p>视图和展示器之间边界处是一个使用 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> 的好地方。在这个示例中，视图控制器可以返回一个代表按钮操作的信号。这将允许展示器在不打破职责分离的前提下轻松地对那些信号进行响应。</p>

<h3>路由</h3>

<p>屏幕间的路径会在交互设计师创建的线框 (wireframes) 里进行定义。在 VIPER 中，路由是由两个部分来负责的：展示器和线框。一个线框对象包括 <code>UIWindow</code>，<code>UINavigationController</code>，<code>UIViewController</code> 等部分，它负责创建视图/视图控制器并将其装配到窗口中。</p>

<p>由于展示器包含了响应用户输入的逻辑，因此它就拥有知晓何时导航至另一个屏幕以及具体是哪一个屏幕的能力。而同时，线框知道如何进行导航。在两者结合起来的情况下，展示器可以使用线框来进行实现导航功能，它们两者一起描述了从一个屏幕至另一个屏幕的路由过程。</p>

<p>线框同时也明显是一个处理导航转场动画的地方。来看看这个 add wireframe 中的例子吧：</p>

<pre><code>@implementation VTDAddWireframe

- (void)presentAddInterfaceFromViewController:(UIViewController *)viewController 
{
    VTDAddViewController *addViewController = [self addViewController];
    addViewController.eventHandler = self.addPresenter;
    addViewController.modalPresentationStyle = UIModalPresentationCustom;
    addViewController.transitioningDelegate = self;

    [viewController presentViewController:addViewController animated:YES completion:nil];

    self.presentedViewController = viewController;
}

#pragma mark - UIViewControllerTransitioningDelegate Methods

- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed 
{
    return [[VTDAddDismissalTransition alloc] init];
}

- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented
                                                                  presentingController:(UIViewController *)presenting
                                                                      sourceController:(UIViewController *)source 
{
    return [[VTDAddPresentationTransition alloc] init];
}

@end
</code></pre>

<p>应用使用了自定义的视图控制器转场来呈现 add view controller。因为线框部件负责实施这个转场，所以它成为了 add view controller 转场的委托，并且返回适当的转场动画。</p>

<h2>利用 VIPER 组织应用组件</h2>

<p>iOS 应用的构架需要考虑到 UIKit 和 Cocoa Touch 是建立应用的主要工具。架构需要和应用的所有组件都能够和平相处，但又需要为如何使用框架的某些部分以及它们应该在什么位置提供一些指导和建议。</p>

<p>iOS 应用程序的主力是 <code>UIViewController</code>，我们不难想象找一个竞争者来取代 MVC 就可以避免大量使用视图控制器。但是视图控制器现在是这个平台的核心：它们处理设备方向的变化，回应用户的输入，和类似导航控制器之类的系统系统组件集成得很好，而现在在 iOS 7 中又能实现自定义屏幕之间的转换，功能实在是太强大了。</p>

<p>有了 VIPER，视图控制器便就能真正的做它本来应该做的事情了，那就是控制视图。 我们的待办事项应拥有两个视图控制器，一个是列表视图，另一个是新建待办。因为 add view controller 要做的所有事情就是控制视图，所以实现起来非常的简单基础：</p>

<pre><code>@implementation VTDAddViewController

- (void)viewDidAppear:(BOOL)animated 
{
    [super viewDidAppear:animated];

    UITapGestureRecognizer *gestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self
                                                                                        action:@selector(dismiss)];
    [self.transitioningBackgroundView addGestureRecognizer:gestureRecognizer];
    self.transitioningBackgroundView.userInteractionEnabled = YES;
}

- (void)dismiss 
{
    [self.eventHandler cancelAddAction];
}

- (void)setEntryName:(NSString *)name 
{
    self.nameTextField.text = name;
}

- (void)setEntryDueDate:(NSDate *)date 
{
    [self.datePicker setDate:date];
}

- (IBAction)save:(id)sender 
{
    [self.eventHandler saveAddActionWithName:self.nameTextField.text
                                     dueDate:self.datePicker.date];
}

- (IBAction)cancel:(id)sender 
{
    [self.eventHandler cancelAddAction];
}


#pragma mark - UITextFieldDelegate Methods

- (BOOL)textFieldShouldReturn:(UITextField *)textField 
{
    [textField resignFirstResponder];

    return YES;
}

@end
</code></pre>

<p>应用在接入网络以后会变得更有用处，但是究竟该在什么时候联网呢？又由谁来负责启动网络连接呢？典型的情况下，由交互器来启动网络连接操作的项目，但是它不会直接处理网络代码。它会寻找一个像是 network manager 或者 API client 这样的依赖项。交互器可能聚合来自多个源的数据来提供所需的信息，从而完成一个用例。最终，就由展示器来采集交互器反馈的数据，然后组织并进行展示。</p>

<p>数据存储模块负责提供实体给交互器。因为交互器要完成业务逻辑，因此它需要从数据存储中获取实体并操纵它们，然后将更新后的实体再放回数据存储中。数据存储管理实体的持久化，而实体应该对数据库全然不知，正因如此，实体并不知道如何对自己进行持久化。</p>

<p>交互器同样不需要知道如何将实体持久化，有时交互器更希望使用一个 data manager 来使其与数据存储的交互变得容易。Data manager 可以处理更多的针对存储的操作，比如创建获取请求，构建查询等等。这就使交互器能够将更多的注意力放在应用逻辑上，而不必再了解实体是如何被聚集或持久化的。下面我们举一个例子来说明使用 data manager 有意义的，这个例子假设你在使用 Core Data。这是示例应用程序的 data manager 的接口：</p>

<pre><code>@interface VTDListDataManager : NSObject

@property (nonatomic, strong) VTDCoreDataStore *dataStore;

- (void)todoItemsBetweenStartDate:(NSDate *)startDate endDate:(NSDate *)endDate completionBlock:(void (^)(NSArray *todoItems))completionBlock;

@end
</code></pre>

<p>当使用 TDD 来开发一个交互器时，是可以用一个测试用的模拟存储来代替生产环境的数据存储的。避免与远程服务器通讯（网络服务）以及避免读取磁盘（数据库）可以加快你测试的速度并加强其可重复性。</p>

<p>将数据存储保持为一个界限清晰的特定层的原因之一是，这可以让你延迟选择一个特定的持久化技术。如果你的数据存储是一个独立的类，那你就可以使用一个基础的持久化策略来开始你的应用，然后等到有意义的时候升级至 SQLite 或者 Core Data。而因为数据存储层的存在，你的应用代码库中就不需要改变任何东西。</p>

<p>在 iOS 的项目中使用 Core Data 经常比构架本身还容易引起更多争议。然而，利用 VIPER 来使用 Core Data 将给你带来使用 Core Data 的前所未有的良好体验。在持久化数据的工具层面上，Core Data 可以保持快速存取和低内存占用方面，简直是个神器。但是有个很恼人的地方，它会像触须一样把 <code>NSManagedObjectContext</code>  延伸至你所有的应用实现文件中，特别是那些它们不该待的地方。VIPER 可以使 Core Data 待在正确的地方：数据存储层。</p>

<p>在待办事项示例中，应用仅有的两部分知道使用了 Core Data，其一是数据存储本身，它负责建立 Core Data 堆栈；另一个是 data manager。Data manager 执行了获取请求，将数据存储返回的 NSManagedObject 对象转换为标准的 PONSO 模型对象，并传输回业务逻辑层。这样一来，应用程序核心将不再依赖于 Core Data，附加得到的好处是，你也再也不用担心过期数据 (stale) 和没有良好组织的多线程 NSManagedObjects 来糟蹋你的工作成果了。</p>

<p>在通过请求访问 Core Data 存储时，data manager 中看起来是这样的：</p>

<pre><code>@implementation VTDListDataManager

- (void)todoItemsBetweenStartDate:(NSDate *)startDate endDate:(NSDate*)endDate completionBlock:(void (^)(NSArray *todoItems))completionBlock
{
    NSCalendar *calendar = [NSCalendar autoupdatingCurrentCalendar];

    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"(date &gt;= %@) AND (date &lt;= %@)", [calendar dateForBeginningOfDay:startDate], [calendar dateForEndOfDay:endDate]];
    NSArray *sortDescriptors = @[];

    __weak typeof(self) welf = self;
    [self.dataStore
     fetchEntriesWithPredicate:predicate
     sortDescriptors:sortDescriptors
     completionBlock:^(NSArray* entries) {
         if (completionBlock)
         {
             completionBlock([welf todoItemsFromDataStoreEntries:entries]);
         }
     }];
}

- (NSArray*)todoItemsFromDataStoreEntries:(NSArray *)entries
{
    return [entries arrayFromObjectsCollectedWithBlock:^id(VTDManagedTodoItem *todo) {
        return [VTDTodoItem todoItemWithDueDate:todo.date name:todo.name];
    }];
}

@end
</code></pre>

<p>与 Core Data 一样极富争议的恐怕就是 UI 故事板了。故事板具有很多有用的功能，如果完全忽视它将会是一个错误。然而，调用故事版所能提供的所有功能来完成 VIPER 的所有目标仍然是很困难的。</p>

<p>我们所能做出的妥协就是选择不使用 segues 。有时候使用 segues 是有效的，但是使用 segues 的危险性在于它们很难原封不动地保持屏幕之间的分离，以及 UI 和应用逻辑之间的分离。一般来说，如果实现 prepareForSegue 方法是必须的话，我们就尽量不去使用 segues。</p>

<p>除此之外，故事板是一个实现用户界面布局有效方法，特别是在使用自动布局的时候。我们选择在实现待办事项两个界面的实例中使用故事板，并且使用这样的代码来执行自己的导航操作。</p>

<pre><code>static NSString *ListViewControllerIdentifier = @"VTDListViewController";

@implementation VTDListWireframe

- (void)presentListInterfaceFromWindow:(UIWindow *)window 
{
    VTDListViewController *listViewController = [self listViewControllerFromStoryboard];
    listViewController.eventHandler = self.listPresenter;
    self.listPresenter.userInterface = listViewController;
    self.listViewController = listViewController;

    [self.rootWireframe showRootViewController:listViewController
                                      inWindow:window];
}

- (VTDListViewController *)listViewControllerFromStoryboard 
{
    UIStoryboard *storyboard = [self mainStoryboard];
    VTDListViewController *viewController = [storyboard instantiateViewControllerWithIdentifier:ListViewControllerIdentifier];
    return viewController;
}

- (UIStoryboard *)mainStoryboard 
{
    UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@"Main"
                                                         bundle:[NSBundle mainBundle]];
    return storyboard;
}

@end
</code></pre>

<h2>使用 VIPER 构建模块</h2>

<p>一般在使用 VIPER 的时候，你会发现一个屏幕或一组屏幕倾向于聚在一起作为一个模块。模块可以以多种形式体现，但一般最好把它想成是一种特性。在播客应用中，一个模块可能是音频播放器或订阅浏览器。然而在我们的待办事项应用中，列表和添加事项的屏幕都将作为单独的模块被建立。</p>

<p>将你的应用作为一组模块来设计有很多好处，其中之一就是模块可以有非常明确和定义良好的接口，并且独立于其他的模块。这就使增加或者移除特性变得更加简单，也使在界面中向用户展示各种可变模块变得更加简单。</p>

<p>我们希望能将待办事项中各模块之间分隔更加明确，我们为添加模块定义了两个协议。一个是模块接口，它定义了模块可以做什么；另一个则是模块的代理，用来描述该模块做了什么。例如：</p>

<pre><code>@protocol VTDAddModuleInterface &lt;NSObject&gt;

- (void)cancelAddAction;
- (void)saveAddActionWithName:(NSString *)name dueDate:(NSDate *)dueDate;

@end


@protocol VTDAddModuleDelegate &lt;NSObject&gt;

- (void)addModuleDidCancelAddAction;
- (void)addModuleDidSaveAddAction;

@end
</code></pre>

<p>因为模块必须要被展示，才能对用户产生价值，所以模块的展示器通常需要实现模型的接口。当另一个模型想要展现当前模块时，它的展示器就需要实现模型的委托协议，这样它就能在展示时知道当前模块做了些什么。</p>

<p>一个模块可能包括实体，交互器和管理器的通用应用逻辑层，这些通常可用于多个屏幕。当然，这取决于这些屏幕之间的交互及它们的相似度。一个模块可以像在待办事项列表里面一样，简单的只代表一个屏幕。这样一来，应用逻辑层对于它的特定模块的行为来说就非常特有了。</p>

<p>模块同样是组织代码的简便途径。将模块所有的编码都放在它自己的文件夹中并在 Xcode 中建一个 group，这会在你需要寻找和改变更加容易。当你在要寻找一个类时，它恰到好处地就在你所期待的地方，这种感觉真是无法形容的棒。</p>

<p>利用 VIPER 建立模块的另一个好处是它使得扩展到多平台时变得更加简单。独立在交互器层中的所有用例的应用逻辑允许你可以专注于为平板，电话或者 Mac 构建新的用户界面，同时可以重用你的应用层。</p>

<p>进一步来说，iPad 应用的用户界面能够将部分 iPhone 应用的视图，视图控制器及展示器进行再利用。在这种情况下，iPad 屏幕将由 ‘super’ 展示器和线框来代表，这样可以利用 iPhone 使用过的展示器和线框来组成屏幕。建立进而维护一个跨多平台的应用是一个巨大的挑战，但是好的构架可以对整个模型和应用层的再利用有大幅度的提升，并使其实现起来更加容易。</p>

<h2>利用 VIPER 进行测试</h2>

<p>VIPER 的出现激发了一个关注点的分离，这使得采用 TDD 变得更加简便。交互器包含独立与任何 UI 的纯粹逻辑，这使测试驱动开发更加简单。同时展示器包含用来为显示准备数据的逻辑，并且它也独立于任何一个 UIKit 部件。对于这个逻辑的开发也很容易用测试来驱动。</p>

<p>我们更倾向于先从交互器下手。用户界面里所有部分都服务于用例，而通过采用 TDD 来测试驱动交互器的 API 可以让你对用户界面和用例之间的关系有一个更好的了解。</p>

<p>作为实例，我们来看一下负责待办事项列表的交互器。寻找待办事项的策略是要找出所有的将在下周末前截止的项目，并将这些项目分别归类至截止于今天，明天，本周或者下周。</p>

<p>我们编写的第一个测试是为了保证交互器能够找到所有的截止于下周末的待办事项：</p>

<pre><code>- (void)testFindingUpcomingItemsRequestsAllToDoItemsFromTodayThroughEndOfNextWeek
{
    [[self.dataManager expect] todoItemsBetweenStartDate:self.today endDate:self.endOfNextWeek completionBlock:OCMOCK_ANY];
    [self.interactor findUpcomingItems];
}
</code></pre>

<p>一旦知道了交互器找到了正确的待办事项后，我们就需要编写几个小测试用来确认它确实将待办事项分配到了正确的相对日期组内（比如说今天，明天，等等）。</p>

<pre><code>- (void)testFindingUpcomingItemsWithOneItemDueTodayReturnsOneUpcomingItemsForToday
{
    NSArray *todoItems = @[[VTDTodoItem todoItemWithDueDate:self.today name:@"Item 1"]];
    [self dataStoreWillReturnToDoItems:todoItems];

    NSArray *upcomingItems = @[[VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationToday dueDate:self.today title:@"Item 1"]];
    [self expectUpcomingItems:upcomingItems];

    [self.interactor findUpcomingItems];
}
</code></pre>

<p>既然我们已经知道了交互器的 API 长什么样，接下来就是开发展示器。一旦展示器接收到了交互器传来的待办事项，我们就需要测试看看我们是否适当的将数据进行格式化并且在用户界面中正确的显示它。</p>

<pre><code>- (void)testFoundZeroUpcomingItemsDisplaysNoContentMessage
{
    [[self.ui expect] showNoContentMessage];

    [self.presenter foundUpcomingItems:@[]];
}

- (void)testFoundUpcomingItemForTodayDisplaysUpcomingDataWithNoDay
{
    VTDUpcomingDisplayData *displayData = [self displayDataWithSectionName:@"Today"
                                                          sectionImageName:@"check"
                                                                 itemTitle:@"Get a haircut"
                                                                itemDueDay:@""];
    [[self.ui expect] showUpcomingDisplayData:displayData];

    NSCalendar *calendar = [NSCalendar gregorianCalendar];
    NSDate *dueDate = [calendar dateWithYear:2014 month:5 day:29];
    VTDUpcomingItem *haircut = [VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationToday dueDate:dueDate title:@"Get a haircut"];

    [self.presenter foundUpcomingItems:@[haircut]];
}

- (void)testFoundUpcomingItemForTomorrowDisplaysUpcomingDataWithDay
{
    VTDUpcomingDisplayData *displayData = [self displayDataWithSectionName:@"Tomorrow"
                                                          sectionImageName:@"alarm"
                                                                 itemTitle:@"Buy groceries"
                                                                itemDueDay:@"Thursday"];
    [[self.ui expect] showUpcomingDisplayData:displayData];

    NSCalendar *calendar = [NSCalendar gregorianCalendar];
    NSDate *dueDate = [calendar dateWithYear:2014 month:5 day:29];
    VTDUpcomingItem *groceries = [VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationTomorrow dueDate:dueDate title:@"Buy groceries"];

    [self.presenter foundUpcomingItems:@[groceries]];
}
</code></pre>

<p>同样需要测试的是应用是否在用户想要新建待办事项时正确启动了相应操作：</p>

<pre><code>- (void)testAddNewToDoItemActionPresentsAddToDoUI
{
    [[self.wireframe expect] presentAddInterface];

    [self.presenter addNewEntry];
}
</code></pre>

<p>这时我们可以开发视图功能了，并且在没有待办事项的时候我们想要展示一个特殊的信息。</p>

<pre><code>- (void)testShowingNoContentMessageShowsNoContentView
{
    [self.view showNoContentMessage];

    XCTAssertEqualObjects(self.view.view, self.view.noContentView, @"the no content view should be the view");
}
</code></pre>

<p>有待办事项出现时，我们要确保列表是显示出来的：</p>

<pre><code>- (void)testShowingUpcomingItemsShowsTableView
{
    [self.view showUpcomingDisplayData:nil];

    XCTAssertEqualObjects(self.view.view, self.view.tableView, @"the table view should be the view");
}
</code></pre>

<p>首先建立交互器是一种符合 TDD 的自然规律。如果你首先开发交互器，紧接着是展示器，你就可以首先建立一个位于这些层的套件测试，并且为实现这是实例奠定基础。由于你不需要为了测试它们而去与用户界面进行交互，所以这些类可以进行快速迭代。在你需要开发视图的时候，你会有一个可以工作并测试过的逻辑和表现层来与其进行连接。在快要完成对视图的开发时，你会发现第一次运行程序时所有部件都运行良好，因为你所有已通过的测试已经告诉你它可以工作。</p>

<h2>结论</h2>

<p>我们希望你喜欢这篇对 VIPER 的介绍。或许你们都很好奇接下来应该做什么，如果你希望通过 VIPER 来对你下一个应用进行设计，该从哪里开始呢？</p>

<p>我们竭尽全力使这篇文章和我们利用 VIPER 实现的应用实例足够明确并且进行了很好的定义。我们的待办事项里列表程序相当直接简单，但是它准确地解释了如何利用 VIPER 来建立一个应用。在实际的项目中，你可以根据你自己的挑战和约束条件来决定要如何实践这个例子。根据以往的经验，我们的每个项目在使用 VIPER 时都或多或少地改变了一些策略，但它们无一例外的都从中得益，找到了正确的方向。</p>

<p>很多情况下由于某些原因，你可能会想要偏离 VIPER 所指引的道路。可能你遇到了很多 <a href="http://inessential.com/2014/03/16/smaller_please">&#8216;bunny&#8217;</a> 对象，或者你的应用使用了故事板的 segues。没关系的，在这些情况下，你只需要在做决定时稍微考虑下 VIPER 所代表的精神就好。VIPER 的核心在于它是建立在<a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">单一责任原则</a>上的架构。如果你碰到了些许麻烦，想想这些原则再考虑如何前进。</p>

<p>你一定想知道在现有的应用中能否只用 VIPER 。在这种情况下，你可以考虑使用 VIPER 构建新的特性。我们许多现有项目都使用了这个方法。你可以利用 VIPER 建立一个模块，这能帮助你发现许多建立在单一责任原则基础上造成难以运用架构的现有问题。</p>

<p>软件开发最伟大的事情之一就是每个应用程序都是不同的，而设计每个应用的架构的方式也是不同的。这就意味着每个应用对于我们来说都是一个学习和尝试的机遇，如果你决定开始使用 VIPER，你会受益匪浅。感谢你的阅读。</p>

<h2>Swift 补充</h2>

<p>苹果上周在 WWDC 介绍了一门称之为 <a href="https://developer.apple.com/swift/">Swift</a> 的编程语言来作为 Cocoa 和 Cocoa Touch 开发的未来。现在发表关于 Swift 的完整意见还为时尚早，但众所周知编程语言对我们如何设计和构建应用有着重大影响。我们决定使用 <a href="https://github.com/objcio/issue-13-viper-swift">Swift 重写我们的待办事项清单</a>，帮助我们学习它对 VIPER 意味着什么。至今为止，收获颇丰。Swift 中的一些特性对于构建应用的体验有着显著的提升。</p>

<h3>结构体</h3>

<p>在 VIPER 中我们使用小型，轻量级的 model 类来在比如从展示器到视图这样不同的层间传递数据。这些 PONSOs 通常是只是简单地带有少量数据，并且通常这些类不会被继承。Swift 的结构体非常适合这个情况。下面的结构体的例子来自 VIPER Swift。这个结构体需要被判断是否相等，所以我们重载了 == 操作符来比较这个类型的两个实例。</p>

<pre><code>struct UpcomingDisplayItem : Equatable, Printable {
    let title : String = ""
    let dueDate : String = ""

    var description : String { get {
        return "\(title) -- \(dueDate)"
    }}

    init(title: String, dueDate: String) {
        self.title = title
        self.dueDate = dueDate
    }
}

func == (leftSide: UpcomingDisplayItem, rightSide: UpcomingDisplayItem) -&gt; Bool {
    var hasEqualSections = false
    hasEqualSections = rightSide.title == leftSide.title

    if hasEqualSections == false {
        return false
    }

    hasEqualSections = rightSide.dueDate == rightSide.dueDate

    return hasEqualSections
}
</code></pre>

<h3>类型安全</h3>

<p>也许 Objective-C 和 Swift 的最大区别是它们在对于类型处理上的不同。 Objective-C 是动态类型，而 Swift 故意在编译时做了严格的类型检查。对于一个类似 VIPER 的架构， 应用由不同层构成，类型安全是提升程序员效率和设计架构有非常大的好处。编译器帮助你确保正确类型的容器和对象在层的边界传递。如上所示，这是一个使用结构体的好地方。如果一个结构体的被设计为存在于两层之间，那么由于类型安全，你可以保证它将永远无法脱离这些层之间。</p>

<h2>扩展阅读</h2>

<ul>
<li><a href="https://github.com/objcio/issue-13-viper">VIPER TODO, 文章示例</a></li>
<li><a href="https://github.com/objcio/issue-13-viper-swift">VIPER SWIFT, 基于 Swift 的文章示例</a></li>
<li><a href="https://github.com/mutualmobile/Counter">另一个计数器应用</a></li>
<li><a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/">Mutual Mobile 关于 VIPER 的介绍</a></li>
<li><a href="http://blog.8thlight.com/uncle-bob/2011/11/22/Clean-Architecture.html">简明架构</a></li>
<li><a href="http://objccn.io/issue-1-1/">更轻量的 View Controllers</a></li>
<li><a href="http://objccn.io/issue-1-3/">测试 View Controllers</a></li>
<li><a href="http://inessential.com/2014/03/16/smaller_please">Bunnies</a></li>
</ul>


<hr />

<p><a href="http://objccn.io/issue-13">话题 #13 下的更多文章</a></p>

<p>原文 <a href="http://www.objc.io/issue-13/viper.html">Architecting iOS Apps with VIPER</a></p>


  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2014/06/03/issue-10-2-weekwood/">2014-04-12-issue-10-2-weekwood</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2014-06-03T12:27:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Jun 3<span>rd</span>, 2014</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2014/06/03/issue-10-2-weekwood/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




  <p>当乔布斯第一次在苹果全球开发大会上介绍 <a href="http://en.wikipedia.org/wiki/ICloud">iCloud</a> 的时候，他将无缝同步的功能描述的太过完美，以至于让人怀疑其是否真的能实现。但当你在 <a href="http://adcdownload.apple.com//videos/wwdc_2011__hd/session_303__whats_new_in_core_data_on_ios.m4v">iOS 5</a> 和 <a href="http://adcdownload.apple.com//videos/wwdc_2012__hd/session_227__using_icloud_with_core_data.mov">iOS 6</a> 系统中尝试使用 iCloud <a href="http://www.objc.io/issue-4/core-data-overview.html">Core Data</a> 同步的时候你会对其真实情况了如指掌。</p>

<p><a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/MOSXAppProgrammingGuide/CoreAppDesign/CoreAppDesign.html#//apple_ref/doc/uid/TP40010543-CH3-SW3">库风格应用</a>(译者注:&#8221;盒子类型&#8221;，比如 iPhoto )的同步中的问题导致<a href="http://www.macworld.com/article/1167742/developers_dish_on_iclouds_challenges.html">很多</a><a href="http://blog.caffeine.lu/problems-with-core-data-icloud-storage.html">开发者</a><a href="http://www.jumsoft.com/2013/01/response-to-sync-issues/">放弃</a>支持 iCloud，而选择一些其他的方案比如 <a href="http://simperium.com">Simperium</a>，<a href="https://github.com/nothirst/TICoreDataSync">TICoreDataSync</a> 和 <a href="http://www.wasabisync.com">WasabiSync</a>。</p>

<p>2013年初，在苹果公司不透明及充满 bug 的 iCloud Core Data 同步实现中挣扎多年后，开发者终于公开批判了这项服务的重大缺陷并将这个话题推上了<a href="http://arstechnica.com/apple/2013/03/frustrated-with-icloud-apples-developer-community-speaks-up-en-masse/">风口浪尖</a>。 最终被 Ellis Hamburger 在一篇<a href="http://www.theverge.com/2013/3/26/4148628/why-doesnt-icloud-just-work">尖锐文章</a>提出。</p>

<h2>WWDC</h2>

<p>苹果也注意到了，很明显这些事情必须改变。在 WWDC 2013，<a href="http://about.me/nickgillett">Nick Gillett</a> 宣布 Core Data 团队花了一年时间专注于在 iOS 7 中解决一些 iCloud 最令人挫败的漏洞，承诺大幅改善问题并且让开发者更简单的使用。“我们明显减少了开发者所需要编写的复杂代码的数量。” Nick Gillett在 [“What’s New in Core Data and iCloud”] 舞台上讲到。 在 iOS 7 中，Apple 专注于 iCloud 的速度，可靠性，和性能，事实上这卓有成效。</p>

<p>让我们看看具体有哪些改变，以及如何在 iOS 7 应用程序实现 Core Data。</p>

<h2>设置</h2>

<p>要设置一个 iCloud Core Data 应用，你首先需要在你的应用中请求 iCloud 的<a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/iCloudDesignGuide/Chapters/iCloudFundametals.html">访问权限</a>，让你的应用程序可以读写一个或多个开放性容器 (ubiquity containers)，在 Xcode 5中你可以在你应用 target 的 <a href="https://developer.apple.com/xcode/">“Capabilities”</a> 选项卡中轻易完成着这一切。</p>

<p>在开放性容器内部，Core Data Framework 将会存储所有的事务日志 &#8211; 记录你的所有持久化的存储 &#8211; 为了跨设备同步数据做准备。 Core Data 使用了一个被称为<a href="http://en.wikipedia.org/wiki/Multi-master_replication">多源复制</a>(multi-master replication)的技术来同步 iOS 和 Macs 之间的数据。可持久化存储的数据存在了每个设备的 <code>CoreDataUbiquitySupport</code> 文件夹里，你可以在应用沙盒中找到他。当用户修改了 iCloud accounts，Core Data framework 会管理多个账户，而并不需要你自己去监听<a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/nsfilemanager_class/Reference/Reference.html#//apple_ref/doc/uid/20000305-SW81"><code>NSUbiquityIdentityDidChangeNotification</code></a>。</p>

<p>每一个事务日志都是一个<code>plist</code>文件，负责实体的跟踪插入，删除以及更新。这些日志会自动被系统按照一定<a href="http://mentalfaculty.tumblr.com/post/23788055417/under-the-sheets-with-icloud-and-core-data-seeding">基准</a>合并。</p>

<p>在你设置iCloud的持久化存储的时候，调用<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSPersistentStoreCoordinator_Class/NSPersistentStoreCoordinator.html#//apple_ref/occ/instm/NSPersistentStoreCoordinator/addPersistentStoreWithType:configuration:URL:options:error:"><code>addPersistentStoreWithType:configuration:URL:options:error:</code></a>或者 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSPersistentStoreCoordinator_Class/NSPersistentStoreCoordinator.html#//apple_ref/doc/uid/TP30001180-BBCFDEGA"><code>migratePersistentStore:toURL:options:withType:error:</code></a>的时候注意需要设置一些<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSPersistentStoreCoordinator_Class/NSPersistentStoreCoordinator.html#//apple_ref/doc/constant_group/Store_Options">选项</a>:</p>

<ul>
<li><p><code>NSPersistentStoreUbiquitousContentNameKey</code> (<code>NSString</code>)<br/>
  给 iCloud 存储空间指定一个名字（例如 @“MyAppStore”）</p></li>
<li><p><code>NSPersistentStoreUbiquitousContentURLKey</code> (<code>NSString</code>, iOS 7 中可选)
  给事务日志指定一个二级目录(例如 @&#8221;Logs&#8221;)</p></li>
<li><p><code>NSPersistentStoreUbiquitousPeerTokenOption</code> (<code>NSString</code>, 可选)<br/>
  为每个程序设置一个盐，为了让不同应用可以在同一个集成 iCloud 的设备中分享 Core Data 数据 (比如<code>@"d70548e8a24c11e3bbec425861b86ab6"</code>)</p></li>
<li><p><code>NSPersistentStoreRemoveUbiquitousMetadataOption</code> (<code>NSNumber</code> (Boolean), 可选)
  指定程序是否需要备份或迁移 iCloud 的元数据(例如 <code>@YES</code>)</p></li>
<li><p><code>NSPersistentStoreUbiquitousContainerIdentifierKey</code> (<code>NSString</code>)<br/>
  指定一个容器，如果你的应用有多个容器定义在 entitlements 中(例如 <code>@"com.company.MyApp.anothercontainer"</code>)</p></li>
<li><p><code>NSPersistentStoreRebuildFromUbiquitousContentOption</code> (<code>NSNumber</code> (Boolean), 可选)
  告诉 Core Data 抹除本地存储数据并且用 iCoud 重建数据(例如 <code>@YES</code>)</p></li>
</ul>


<p>只支持 iOS 7 的应用的唯一必填选项是 ContentNameKey，它是为了让 Core Data 知道把日志和元数据放在哪里。在 iOS 7 中，你传入 NSPersistentStoreUbiquitousContentNameKey 的字符串值不应该包含&#8217;.&#8217;。 如果你的应用已经使用 Core Data 去存储持久化数据，但是没有实现 iCloud 同步，你只需要简单加入 content name key 就能将存储转为可以使用 iCloud 的状态，而无需关注有没有活跃的 iCloud 账户。</p>

<p>为你的应用设置一个管理对象上下文简单到只需要实例化一个 <code>NSManagedObjectContext</code> 并连同一个合并策略一并告诉你的持久化存储。苹果建议使用 <code>NSMergeByPropertyObjectTrumpMergePolicy</code> 作为合并策略，它会合并冲突，并给予内存中的变化的数据相较于磁盘数据更高的优先级。</p>

<p>虽然 Apple 还没有发布官方的 iOS7 中 iCloud Core Data 的示例代码，但是 Apple 的 Core Data 团队中的一个工程师在<a href="https://devforums.apple.com/message/828503#828503">开发者论坛</a>上提供了这个模板。我们稍微修改让它更清晰:</p>

<pre><code>#pragma mark - Notification Observers
- (void)registerForiCloudNotifications {
    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];

    [notificationCenter addObserver:self 
                           selector:@selector(storesWillChange:) 
                               name:NSPersistentStoreCoordinatorStoresWillChangeNotification 
                             object:self.persistentStoreCoordinator];

    [notificationCenter addObserver:self 
                           selector:@selector(storesDidChange:) 
                               name:NSPersistentStoreCoordinatorStoresDidChangeNotification 
                             object:self.persistentStoreCoordinator];

    [notificationCenter addObserver:self 
                           selector:@selector(persistentStoreDidImportUbiquitousContentChanges:) 
                               name:NSPersistentStoreDidImportUbiquitousContentChangesNotification 
                             object:self.persistentStoreCoordinator];
}

# pragma mark - iCloud Support

/// 在 -addPersistentStore: 使用这些配置
- (NSDictionary *)iCloudPersistentStoreOptions {
    return @{NSPersistentStoreUbiquitousContentNameKey: @"MyAppStore"};
}

- (void) persistentStoreDidImportUbiquitousContentChanges:(NSNotification *)notification {
    NSManagedObjectContext *context = self.managedObjectContext;

    [context performBlock:^{
        [context mergeChangesFromContextDidSaveNotification:changeNotification];
    }];
}

- (void)storesWillChange:(NSNotification *)notification {
    NSManagedObjectContext *context = self.managedObjectContext;

    [context performBlockAndWait:^{
        NSError *error;

        if ([context hasChanges]) {
            BOOL success = [context save:&amp;error];

            if (!success &amp;&amp; error) {
                // 执行错误处理
                NSLog(@"%@",[error localizedDescription]);
            }
        }

        [context reset];
    }];

    // 刷新界面
}

- (void)storesDidChange:(NSNotification *)notification {
    // 刷新界面
}
</code></pre>

<h3>异步持久化设置</h3>

<p>在 iOS 7 中，使用 iCloud 选项来调用 <code>addPersistentStoreWithType:configuration:URL:options:error:</code> 几乎可以瞬间返回存储对象。[<sup>1]</sup> 能做到这样是因为它首先设置了一个内部‘回滚’存储，利用本地存储作为一个占位符，同时由事务日志和元数据来异步地构建 iCloud 存储。当回滚存储有变化时，这些变化将在 iCloud 存储被添加到 coordinator 时合并至其中。在完成回滚存储的设置后，控制台将会打印<code>Using local storage: 1</code> ，当 iCloud 完全设置完后，你会看到 <code>Using local storage: 0</code>。 这句话的意思是 iCloud 存储已经启用，此后你可以通过监听<code>NSPersistentStoreDidImportUbiquitousContentChangesNotification</code>看到来自 iCloud 的内容。</p>

<p>如果你的应用关注在不同存储间的迁移，那么你需要监听 <code>NSPersistentStoreCoordinatorStoresWillChangeNotification</code> 和/或<code>NSPersistentStoreCoordinatorStoresDidChangeNotification</code>(将这些通知关联到你的 coordinator，这样就可以过滤其他和你无关的通知) 并且在 <code>userInfo</code> 中检查 <code>NSPersistentStoreUbiquitousTransitionTypeKey</code> 的值， 这个数值是一个对应 <a href="https://developer.apple.com/library/ios/documentation/cocoa/Reference/CoreDataFramework/Classes/NSPersistentStoreCoordinator_Class/NSPersistentStoreCoordinator.html#//apple_ref/c/tdef/NSPersistentStoreUbiquitousTransitionType"><code>NSPersistentStoreUbiquitousTransitionType</code></a> 枚举类型的 NSNumber，在迁移已经发生时，这个值是<code>NSPersistentStoreUbiquitousTransitionTypeInitialImportCompleted</code>。</p>

<h2>边缘情况</h2>

<h3>混淆 (Churn)</h3>

<p>在 iOS 5 和 iOS 6 中测试 iCloud 时最严重的一个问题是重度用户的账号会遇到一种“混淆”的状态，导致无法使用。同步将完全停止，甚至删除开放性数据也无法使其正常工作。在 <a href="http://lickability.com">Lickability</a>，我们亲切地称为这种状态“f * \ \ * \ * ing bucket。”</p>

<p>在 iOS 7 中，系统提供了一个方法来真正移除全部的开放性存储内容: <code>+removeUbiquitousContentAndPersistentStoreAtURL:options:error:</code>，这个方法对测试很有帮助，甚至在你应用中，当你用户进入了一个不正常的状态时，他们可以通过这个方法删除所有数据，并重新来过。不过，需要指出的是：首先，这种方法是同步的。甚至在做网络操作的时候它也是同步的，因此它会花很长时间，并且在完成前也不会返回。第二，绝对不能在有持久性存储 coordinators 活跃时执行此操作。这样会造成很严重的问题，你的应用程序可能进入一个不可恢复的状态，而且官方指导指出所有活跃的持久性存储 coordinators 都应在使用这个方法前完全销毁收回。</p>

<h3>账户修改</h3>

<p>iOS 5 系统中，用户在切换 iCloud 账户或者禁用账户时，<code>NSPersistentStoreCoordinator</code> 中的数据会在应用无法知晓的情况下完全消失。事实上检查一个账号是否变更了的唯一的方法是调用 <code>NSFileManager</code> 中的 <code>URLForUbiquityContainerIdentifier</code>，这个方法可以创建一个开放性容器文件夹，而且需要数秒返回。在 iOS 6，这种情况随着引进 <code>ubiquityIdentityToken</code> 和相应的<code>NSUbiquityIdentityDidChangeNotification</code> 之后得到改善。因为在 ubiquity id 变化的时候会发送通知，这就可以对应用账户的变更进行有效的确认并及时的发出提示。</p>

<p>然而，iOS 7 中这种转换的情况就变得更加简单，账户的切换是由 Core Data 框架来处理的，因此只要你的程序能够正常响应 <code>NSPersistentStoreCoordinatorStoresWillChangeNotification</code> 和 <code>NSPersistentStoreCoordinatorStoresDidChangeNotification</code> 便可以在切换账户的时候流畅的更换信息。检查 <code>userInfo</code> 的字典中 <code>NSPersistentStoreUbiquitousTransitionType</code> 键将提供更多关于迁移的类型的细节。</p>

<p>在应用沙箱中框架会为每个账户管理各自独立的持久化存储，所以这就意味着如果用户回到之前的账户，其数据会和之前离开时一样，仍然可用。Core Data 现在也会在磁盘空间不足时管理对这些文件进行的清理工作。</p>

<h3>iCloud 的启用与停用</h3>

<p>在 iOS 7 中应用实现用一个开关用来切换启用关闭 iCloud 变的非常容易，虽然对大部分应用来说这个功能不是很需要，因为在创建 <code>NSPersistentStore</code> 时候如果加入 iCloud 选项，那么 API 现在将自动建立一个独立的文件结构，这意味着本地存储和 iCloud 存储共用相同的存储 URL 和其他很多设置。这个选项将把 ubiquitous 元数据和存储本身进行分离，并专门为迁移或者复制的场景进行了特殊设计。下面是一个示例:</p>

<pre><code>- (void)migrateiCloudStoreToLocalStore {
    // 假设你只有一个存储
    NSPersistentStore *store = [[_coordinator persistentStores] firstObject]; 

    NSMutableDictionary *localStoreOptions = [[self storeOptions] mutableCopy];
    [localStoreOptions setObject:@YES forKey:NSPersistentStoreRemoveUbiquitousMetadataOption];

    NSPersistentStore *newStore =  [_coordinator migratePersistentStore:store 
                                                                  toURL:[self storeURL] 
                                                                options:localStoreOptions 
                                                               withType:NSSQLiteStoreType error:nil];

    [self reloadStore:newStore];
}

- (void)reloadStore:(NSPersistentStore *)store {
    if (store) {
        [_coordinator removePersistentStore:store error:nil];
    }

    [_coordinator addPersistentStoreWithType:NSSQLiteStoreType 
                               configuration:nil 
                                         URL:[self storeURL] 
                                     options:[self storeOptions] 
                                       error:nil];
}
</code></pre>

<p>切换一个本地存储到　iCloud 存储是一个非常容易的事情，简单到只需启用 iCloud 选项，并且把拥有相同选项的可持久存储加入到 coordinator 中。</p>

<h3>外部文件的引用</h3>

<p>外部文件的应用是一个在 iOS 5　中加入的 Core Data 新特性，允许大尺寸的二进制自动存储在 SQLite 数据库之外的文件系统中。 在我们测试中，当发生改变时，iCloud 并不知道如何解决依赖关系并会抛出异常。如果你计划使用 iCloud 同步 ,可以考虑在 iCloud entities 中取消这个选择:</p>

<p><img src="http://cloud.mttb.me/UBrx/image.png" alt="Core Data Modeler Checkbox" /></p>

<h3>Model 版本</h3>

<p>如果你计划使用 iCloud，存储的内容只能在未来兼容自动<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/CoreDataVersioning/Articles/vmLightweightMigration.html">轻量级迁移</a>，
这意味着 Core Data 需要能推断出映射，你也不能提供自己的映射模型。在未来只有对 Model 的简单改变，比如添加和重命名属性，才能被支持。在考虑是否使用 Core Data 同步时，一定要考虑到你的 app 的 Model 在未来版本中改变的情况。</p>

<h3>合并冲突</h3>

<p>在任何同步系统中，服务器和客户端之前的文件冲突是不可避免的。不同于 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/iCloudDesignGuide/Chapters/DesigningForDocumentsIniCloud.html#//apple_ref/doc/uid/TP40012094-CH2-SW1">iCloud Data 文档同步</a>的 APIs, iCloud 的 Core Data 整合并没有明确允许处理本地存储和事务日志之间的冲突。这其实是因为 Core Data 已经支持通过实现 <code>NSMergePolicy</code> 的子类来自定义策合并策略。 如果你要处理冲突，创建 <code>NSMergePolicy</code> 的子类并且覆盖 <code>resolveConflicts:error:</code> 来决定在冲突发生的时候做什么。然后在你的 <code>NSManagedObjectContext</code> 子类中，让<code>mergePolicy</code> 方法返回一个你自定义的策略的实例。</p>

<h3>界面更新</h3>

<p>很多库风格应用同时显示集合对象和一个对象的详细信息。 视图是由 <code>NSFetchedResultsController</code> 实例自动从网络更新 Core Data 的数据然后刷新。然而，您应该确保每一个详细视图正确监听变化对象并使自己保持最新。如果你不这样做, 将有显示陈旧的数据的风险，或者更糟，你将覆盖其他设备修改的数据。</p>

<h2>测试</h2>

<h3>本地网络和因特网同步</h3>

<p>iCloud 守护进程将使用本地网络或使用因特网这两种方式中的其中一种，来进行跨设备的数据同步。守护进程检测到两个设备时，也被称为对等网络，在同一个局域网，将在内网快速传输。然而，如果在不同的网络，该系统将传输回滚事务日志。这很重要，你必须在开发中对两种情况进行大量的测试，以确保您的应用程序正常运作。在这两种场景中，从备份存储同步更改或过渡到 iCloud 有时需要比预期更长的时间，所以如果有什么不工作，尝试给它点时间。</p>

<h3>模拟器中使用 iCloud</h3>

<p>在 iOS 7 中最有用的更新就是 iCloud 终于可以在<a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/iCloudDesignGuide/Chapters/TestingandDebuggingforiCloud.html">模拟器</a>中使用。在以往的版本中，你只能在设备中测试，这个限制使监听开发的同步进程有点困难。现在你甚至可以在你的 Mac 和模拟器中进行数据同步。</p>

<p>在 Xcode 5 新增的 iCloud 调试仪表中，你可以看到在你的应用程序的开放性存储中的文件，以及检查它们的文件传输状态，比如 &#8220;Current&#8221;， &#8220;Excluded&#8221;， 和 &#8220;Stored in Cloud&#8221; 等。 对于更底层的调试，可以把 <code>-com.apple.coredata.ubiquity.logLevel 3</code> 加入到启动参数或者设置成用户默认，以启用详细日志。还可以考虑在 iOS 中安装 <a href="http://developer.apple.com/downloads">iCloud 存储调试日志配置文件</a> 以及新的 <a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/Manpages/man1/ubcontrol.1.html"><code>ubcontrol</code></a> 命令行工具提供高质量错误报告到Apple 。你可以在你的设备连入 iTunes 并同步后在 <code>~/Library/Logs/CrashReporter/MobileDevice/device-name/DiagnosticLogs</code>
 中获取这些工具生成的日志。</p>

<p>然而，iCloud Core Data 并不完全支持模拟器。在用实际设备和模拟器测试传输时，似乎模拟器的 iCloud Core Data 只上传更改，却从不把它们抓取下来。虽然比起分别使用多个不同测试设备来说，确实进步和方便了很多，但是 iOS 模拟器上的 iCloud Core Data 支持绝对还没有完全成熟。</p>

<h2>继续改进</h2>

<p>因为 iOS 7 中 APIs 和功能得到了极大的改善，那些在 iOS 5 和 iOS 6 上分发的带有 iCloud Core Data 的应用的命运就显得扑朔迷离了。 由于从 API 的角度来看它们完全不同（当然我们从功能角度也验证了这一点)，Apple 的建议对于那些需要传统同步的应用来说并不那么友好。Apple <strong>清楚地</strong> 在<a href="https://devforums.apple.com/thread/199983?start=0&amp;tstart=0*">开发者论坛</a> 上建议，绝对不要在 iOS 7 和之前的设备同步之间同步数据。</p>

<p>事实上，“任何时候你都不应该在 iOS 7 与 iOS 6 同步。iOS 6 将持续造成那些已经在 iOS 7 上修正了的 bug，这样做将会会污染 iCloud 账户。” 保证这种分离的最简单的方法是简单地改变你存储中的 <code>NSPersistentStoreUbiquitousContentNameKey</code>，遵循规范进行命名。这样保证从旧版本数据同步的方法是孤立的，并允许开发人员从老旧的实现中完全脱身。</p>

<h2>发布</h2>

<p>发布一个 iCloud Core Data 应用仍旧有很大的风险，你需要对所有的环节进行测试：账户转换，iCloud 存储空间耗尽，多种设备，Model 的升级，以及设备恢复等。尽管 iCloud 调试仪表和 <a href="http://developer.icloud.com">developer.icloud.com</a> 对这些有所帮助，但依靠一个你完全无法控制的服务来发布一个应用仍然需要那种纵身一跃入深渊的信念。</p>

<p>正如 Brent Simmon <a href="http://inessential.com/2013/03/27/why_developers_shouldnt_use_icloud_sy">提到</a>的，发布任意一种 iCloud Syncing 应用都会有限制，所以需要事先了解一下成本。像 <a href="http://dayoneapp.com">Day One</a> 和 <a href="https://agilebits.com/onepassword">1Password</a> 这样的程序，会让使用者选择用 iCloud 还是 Dropbox 来同步他们的数据。对于很多使用者来说，没什么可以比一个独立的账户更加简易，但是一部分动手能力强的人喜欢更好的更全面的控制他们的数据。对于开发者而言，维持这种完全不同的<a href="https://www.dropbox.com/developers/datastore">数据库同步系统</a>在开发和测试的过程当中是十分繁琐和超负荷的。</p>

<h2>Bugs</h2>

<p>一旦你测试并且发布了你的 iCloud Core Data 应用，你很可能会遇到很多框架里的 bug，最好的办法是反馈这些 bug 的详细信息到  <a href="http://bugreport.apple.com">Apple</a>，其中需要包含以下信息：</p>

<ol>
<li>完整的重现步骤</li>
<li>安装了 iCloud 调试配置并将 iCloud 调试日志输出级别调为 3 的终端输出</li>
<li>打包为 zip 的完整的开放性存储内容</li>
</ol>


<h2>结论</h2>

<p>在 iOS 5 和 6 中 iCloud Core Data 根本就没法用这件事已经是不是一个秘密， Apple 的程序员自己都承认“在 iOS 5 和 6 中使用 Core Data + iCloud 时，存在重大的稳定性和长期可靠性的问题，要使用它的话请一定一定一定把应用设为 iOS 7 only“。一些高端的开发者，比如 <a href="http://agiletortoise.com">Agile Tortoise</a> 以及 <a href="http://realmacsoftware.com">Realmac Software</a>，现在已经信任 iCloud Core Data，并把它集成到了他们的应用中。因为有着充分的<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/iCloudDesignGuide/Chapters/Introduction.html">考量</a>和测试，你也应该这么做了。</p>

<p><em>特别感谢 Andrew Harrison, Greg Pierce, and Paul Bruneau 对这篇文章的帮助</em></p>

<hr />

<p><a href="http://objccn.io/issue-10">话题 #10 下的更多文章</a></p>

<p>原文 <a href="http://www.objc.io/issue-10/icloud-core-data.html">iCloud and Core Data</a></p>


  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2014/05/27/issue-12-5-weekwood/">objc.o #issue 12 Collection View 动画</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2014-05-27T09:56:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> May 27<span>th</span>, 2014</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2014/05/27/issue-12-5-weekwood/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




  <p><code>UICollectionView</code> 和相关类的设置非常灵活和强大。但是灵活性一旦增强，某种程度上也增加了其复杂性： <code>UICollectionView</code> 比老式的 <code>UITableView</code> 更有深度，适用性也更强。</p>

<p>Collection View 深入太多了，事实上，<a href="http://oleb.net">Ole Begeman</a> 和 <a href="https://twitter.com/ashfurrow">Ash Furrow</a> 之前曾在 objc.io 上发表过 <a href="http://objccn.io/issue-3-3/">自定义 Collection View 布局</a> 和 <a href="http://objccn.io/issue-5-2/">UICollectionView + UIKit 力学</a>，但是我依然有一些他们没有提及的内容可以写。在这篇文章中，我假设你已经非常熟悉 <code>UICollectionView</code> 的基本布局，并且至少阅读了苹果精彩的<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012334">编程指南</a>以及 Ole 之前的<a href="http://objccn.io/issue-3-3/">文章</a>。</p>

<p>本文的第一部分将集中讨论并举例说明如何用不同的类和方法来共同帮助实现一些常见的 <code>UICollectionView</code> 动画。在第二部分，我们将看一下带有 collection views 的 view controller 转场动画以及在 <code>useLayoutToLayoutNavigationTransitions</code> 可用时使用其进行转场，如果不可用时，我们会实现一个自定义转场动画。</p>

<p>你可以在 GitHub 中找到本文提到的两个示例工程:</p>

<ul>
<li><a href="https://github.com/objcio/issue-12-CollectionViewAnimations">布局动画</a></li>
<li><a href="https://github.com/objcio/issue-12-CustomCollectionViewTransition">自定义 collection view 转场动画</a></li>
</ul>


<h2>Collection View 布局动画</h2>

<p>标准 <code>UICollectionViewFlowLayout</code> 除了动画是非常容易自定义的，苹果选择了一种安全的途径去实现一个简单的淡入淡出动画作为所有布局的默认动画。如果你想实现自定义动画，最好的办法是子类化 <code>UICollectionViewFlowLayout</code> 并且在适当的地方实现你的动画。让我们通过一些例子来了解 <code>UICollectionViewFlowLayout</code> 子类中的一些方法如何协助完成自定义动画。</p>

<h3>插入删除元素</h3>

<p>一般来说，我们对布局属性从初始状态到结束状态进行线性插值来计算 collection view 的动画参数。然而，新插入或者删除的元素并没有最初或最终状态来进行插值。要计算这样的 cells 的动画，collection view 将通过  <code>initialLayoutAttributesForAppearingItemAtIndexPath:</code> 以及 <code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 方法来询问其布局对象，以获取最初的和最后的属性。苹果默认的实现中，对于特定的某个 indexPath，返回的是它的通常的位置，但 <code>alpha</code> 值为 0.0，这就产生了一个淡入或淡出动画。如果你想要更漂亮的效果，比如你的新的 cells 从屏幕底部发射并且旋转飞到对应位置，你可以如下实现这样的布局子类：</p>

<pre><code>- (UICollectionViewLayoutAttributes*)initialLayoutAttributesForAppearingItemAtIndexPath:(NSIndexPath *)itemIndexPath
{
    UICollectionViewLayoutAttributes *attr = [self layoutAttributesForItemAtIndexPath:itemIndexPath];

    attr.transform = CGAffineTransformRotate(CGAffineTransformMakeScale(0.2, 0.2), M_PI);
    attr.center = CGPointMake(CGRectGetMidX(self.collectionView.bounds), CGRectGetMaxY(self.collectionView.bounds));

    return attr;
}
</code></pre>

<p>结果如下：</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-1-insertion.gif" alt="Insertion and Deletion" /></p>

<p>对应的 <code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 方法中，除了设定了不同的 transform 以外，其他都很相似。</p>

<h3>响应设备旋转</h3>

<p>设备方向变化通常会导致 collection view 的 bounds 变化。如果通过 <code>shouldInvalidateLayoutForBoundsChange:</code> 判定为布局需要被无效化并重新计算的时候，布局对象会被询问以提供新的布局。<code>UICollectionViewFlowLayout</code> 的默认实现正确地处理了这个情况，但是如果你子类化 <code>UICollectionViewLayout</code> 的话，你需要在边界变化时返回 <code>YES</code>：</p>

<pre><code>- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds
{
    CGRect oldBounds = self.collectionView.bounds;
    if (!CGSizeEqualToSize(oldBounds.size, newBounds.size)) {
        return YES;
    }
    return NO;
}
</code></pre>

<p>在 bounds 变化的动画中，collection view 表现得像当前显示的元素被移除然后又在新的 bounds 中被被重新插入，这会对每个 IndexPath 产生一系列的 <code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 和 <code>initialLayoutAttributesForAppearingItemAtIndexPath:</code> 的调用。</p>

<p>如果你在插入和删除的时候加入了非常炫的动画，现在你应该看看为何苹果明智的使用简单的淡入淡出动画作为默认效果：</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-2-wrong-rotation.gif" alt="设备旋转的错误反应" /></p>

<p>啊哦&#8230;</p>

<p>为了防止这种不想要的动画，初始化位置 -> 删除动画 -> 插入动画 -> 最终位置的顺序必须完全匹配 collection view 的每一项，以便最终呈现出一个平滑动画。换句话说，<code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 以及 <code>initialLayoutAttributesForAppearingItemAtIndexPath:</code> 应该针对元素到底是真的在显示或者消失，还是 collection view 正在经历的边界改变动画的不同情况，做出不同反应，并返回不同的布局属性。</p>

<p>幸运的是，collection view 会告知布局对象哪一种动画将被执行。它分别通过调用 <code>prepareForAnimatedBoundsChange:</code> 和 <code>prepareForCollectionViewUpdates:</code> 来对应 bounds 变化以及元素更新。出于本实例的说明目的，我们可以使用 <code>prepareForCollectionViewUpdates:</code> 来跟踪更新对象：</p>

<pre><code>- (void)prepareForCollectionViewUpdates:(NSArray *)updateItems
{
    [super prepareForCollectionViewUpdates:updateItems];
    NSMutableArray *indexPaths = [NSMutableArray array];
    for (UICollectionViewUpdateItem *updateItem in updateItems) {
        switch (updateItem.updateAction) {
            case UICollectionUpdateActionInsert:
                [indexPaths addObject:updateItem.indexPathAfterUpdate];
                break;
            case UICollectionUpdateActionDelete:
                [indexPaths addObject:updateItem.indexPathBeforeUpdate];
                break;
            case UICollectionUpdateActionMove:
                [indexPaths addObject:updateItem.indexPathBeforeUpdate];
                [indexPaths addObject:updateItem.indexPathAfterUpdate];
                break;
            default:
                NSLog(@"unhandled case: %@", updateItem);
                break;
        }
    }  
    self.indexPathsToAnimate = indexPaths;
}
</code></pre>

<p>以及修改我们元素的插入动画，让元素只在其正在被插入 collection view 时进行发射：</p>

<pre><code>- (UICollectionViewLayoutAttributes*)initialLayoutAttributesForAppearingItemAtIndexPath:(NSIndexPath *)itemIndexPath
{
    UICollectionViewLayoutAttributes *attr = [self layoutAttributesForItemAtIndexPath:itemIndexPath];

    if ([_indexPathsToAnimate containsObject:itemIndexPath]) {
        attr.transform = CGAffineTransformRotate(CGAffineTransformMakeScale(0.2, 0.2), M_PI);
        attr.center = CGPointMake(CGRectGetMidX(self.collectionView.bounds), CGRectGetMaxY(self.collectionView.bounds));
        [_indexPathsToAnimate removeObject:itemIndexPath];
    }

    return attr;
}
</code></pre>

<p>如果这个元素没有正在被插入，那么将通过 <code>layoutAttributesForItemAtIndexPath</code> 来返回一个普通的属性，以此取消特殊的外观动画。结合 <code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 中相应的逻辑，最终将会使元素能够在 bounds 变化时，从初始位置到最终位置以很流畅的动画形式实现，从而建立一个简单但很酷的动画效果：</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-3-correct-rotation.gif" alt="Wrong reaction to device rotation" /></p>

<h3>交互式布局动画</h3>

<p>Collection views 让用户通过手势实现与布局交互这件事变得很容易。如苹果<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/IncorporatingGestureSupport/IncorporatingGestureSupport.html#//apple_ref/doc/uid/TP40012334-CH4-SW1">建议</a>的那样，为 collection view 布局添加交互的途径一般会遵循以下步骤：</p>

<ol>
<li>创建手势识别</li>
<li>将手势识别添加给 collection view</li>
<li>通过手势来驱动布局动画</li>
</ol>


<p>让我们来看看我们如何可以建立一些用户可缩放捏合的元素，以及一旦用户释放他们的捏合手势元素返回到原始大小。</p>

<p>我们的处理方式可能会是这样：</p>

<pre><code>- (void)handlePinch:(UIPinchGestureRecognizer *)sender {
    if ([sender numberOfTouches] != 2)
        return;


    if (sender.state == UIGestureRecognizerStateBegan ||
        sender.state == UIGestureRecognizerStateChanged) {
        // 获取捏合的点
        CGPoint p1 = [sender locationOfTouch:0 inView:[self collectionView]];
        CGPoint p2 = [sender locationOfTouch:1 inView:[self collectionView]];

        // 计算扩展距离
        CGFloat xd = p1.x - p2.x;
        CGFloat yd = p1.y - p2.y;
        CGFloat distance = sqrt(xd*xd + yd*yd);

        // 更新自定义布局参数以及无效化
        FJAnimatedFlowLayout* layout = (FJAnimatedFlowLayout*)[[self collectionView] collectionViewLayout];

        NSIndexPath *pinchedItem = [self.collectionView indexPathForItemAtPoint:CGPointMake(0.5*(p1.x+p2.x), 0.5*(p1.y+p2.y))];
        [layout resizeItemAtIndexPath:pinchedItem withPinchDistance:distance];
        [layout invalidateLayout];

    }
    else if (sender.state == UIGestureRecognizerStateCancelled ||
             sender.state == UIGestureRecognizerStateEnded){
        FJAnimatedFlowLayout* layout = (FJAnimatedFlowLayout*)[[self collectionView] collectionViewLayout];
        [self.collectionView
         performBatchUpdates:^{
            [layout resetPinchedItem];
         }
         completion:nil];
    }
}
</code></pre>

<p>这个捏合操作需要计算捏合距离并找出被捏合的元素，并且在用户捏合的时候通知布局以实现自身更新。当捏合手势结束的时候，布局会做一个批量更新动画返回原始尺寸。</p>

<p>另一方面，我们的布局始终在跟踪捏合的元素以及期望尺寸，并在需要的时候提供正确的属性：</p>

<pre><code>- (NSArray*)layoutAttributesForElementsInRect:(CGRect)rect
{
    NSArray *attrs = [super layoutAttributesForElementsInRect:rect];

    if (_pinchedItem) {
        UICollectionViewLayoutAttributes *attr = [[attrs filteredArrayUsingPredicate:[NSPredicate predicateWithFormat:@"indexPath == %@", _pinchedItem]] firstObject];

        attr.size = _pinchedItemSize;
        attr.zIndex = 100;
    }
    return attrs;
}
</code></pre>

<h3>小结</h3>

<p>我们通过一些例子来说明了如何在 collection view 布局中创建自定义动画。虽然 <code>UICollectionViewFlowLayout</code> 并不直接允许定制动画，但是苹果工程师提供了清晰的架构让你可以子类化并实现各种自定义行为。从本质来说，在你的 <code>UICollectionViewLayout</code> 子类中正确地响应以下信号，并对那些要求返回 <code>UICollectionViewLayoutAttributes</code> 的方法返回合适的属性，那么实现自定义布局和动画的唯一约束就是你的想象力：</p>

<ul>
<li><code>prepareLayout</code></li>
<li><code>prepareForCollectionViewUpdates:</code></li>
<li><code>finalizeCollectionViewUpdates</code></li>
<li><code>prepareForAnimatedBoundsChange:</code></li>
<li><code>finalizeAnimatedBoundsChange</code></li>
<li><code>shouldInvalidateLayoutForBoundsChange:</code></li>
</ul>


<p>更引人入胜的动画可以结合像在 objc.io <a href="http://objccn.io/issue-5-2/">话题 #5</a> 中 UIKit 力学这样的技术来实现。</p>

<h2>带有 Collection views 的 View controller 转场</h2>

<p>就如 <a href="https://twitter.com/chriseidhof">Chris</a> 之前在 objc.io 的<a href="http://objccn.io/issue-5-3/">文章</a>中所说的那样，iOS 7 中的一个重大更新是自定义 view controller 转场动画。与自定义转场动画相呼应，苹果也在 <code>UICollectionViewController</code> 添加了 <code>useLayoutToLayoutNavigationTransitions</code> 标记来在可复用的单个 collection view 间启用导航转场。苹果自己的照片和日历应用就是这类转场动画的非常好的代表作。</p>

<h3>UICollectionViewController 实例之间的转场动画</h3>

<p>让我们来看看我们如何能够利用上一节相同的示例项目达到类似的效果：</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-4-layout2layout.gif" alt="Layout to Layout Navigation Transitions" /></p>

<p>为了使布局到布局的转场动画工作，navigation controller 的 root view controller 必须是一个 <code>useLayoutToLayoutNavigationTransitions</code> 设置为 <code>NO</code> 的 collection view controller。当另一个 <code>useLayoutToLayoutNavigationTransitions</code> 设置为 <code>YES</code> 的 <code>UICollectionViewController</code> 实例被 push 到根视图控制器之上时，navigation controller 会用布局转场动画来代替标准的 push 转场动画。这里要注意一个重要的细节，根视图控制器的 collection view 实例被回收用于在导航栈上 push 进来的 collection 控制器中，如果你试图在 <code>viewDidLoad</code> 之类的方法中中设置 collection view 属性， 它们将不会有任何反应，你也不会收到任何警告。</p>

<p>这个行为可能最常见的陷阱是期望回收的 collection view 根据顶层的 collection 视图控制器来更新数据源和委托。它当然不会这样：根 collection 视图控制器会保持数据源和委托，除非我们做点什么。</p>

<p>解决此问题的方法是实现 navigation controller 的委托方法，并根据导航堆栈顶部的当前视图控制器的需要正确设置 collection view 的数据源和委托。在我们简单的例子中，这可以通过以下方式实现：</p>

<pre><code>- (void)navigationController:(UINavigationController *)navigationController didShowViewController:(UIViewController *)viewController animated:(BOOL)animated
{
    if ([viewController isKindOfClass:[FJDetailViewController class]]) {
        FJDetailViewController *dvc = (FJDetailViewController*)viewController;
        dvc.collectionView.dataSource = dvc;
        dvc.collectionView.delegate = dvc;
        [dvc.collectionView scrollToItemAtIndexPath:[NSIndexPath indexPathForItem:_selectedItem inSection:0] atScrollPosition:UICollectionViewScrollPositionCenteredVertically animated:NO];
    }
    else if (viewController == self){
        self.collectionView.dataSource = self;
        self.collectionView.delegate = self;
    }
}
</code></pre>

<p>当详细页面的 collection view 被推入导航栈时，我们重新设置 collection view 的数据源到详细视图控制器，确保只有被选择的 cell 颜色显示在详细页面的 collection view 中。如果我们不打算这样做，布局依然可以正确过渡，但是collection 将显示所有的 cells。在实际应用中，detail 的数据源通常负责在转场动画过程中显示更详细的数据。</p>

<h3>用于常规转换的 Collection View 布局动画</h3>

<p>使用了 <code>useLayoutToLayoutNavigationTransitions</code> 的布局和布局间导航转换是很有用的，但却局限于仅在 两个 view controller 都是 <code>UICollectionViewController</code> 的实例，并且转场的必须发生在顶级 collection views 之间。为了达到在任意视图控制器的任意 collection view 之间都能实现相似的过渡，我们需要自定义一个 view collection 的转场动画。</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-5-custom-transitions.gif" alt="Custom Collection View Transition" /></p>

<p>针对此类自定义过渡的动画控制器，需要遵循以下步骤进行设计：</p>

<ol>
<li>对初始的 collection view 中的所有可见元素制作截图</li>
<li>将截图添加到转场上下文的 container view 中</li>
<li>运用目标 collection view 的布局计算最终位置</li>
<li>制作动画使快照到正确的位置</li>
<li>当目标 collection view 可见时删除截图</li>
</ol>


<p>一个这样的动画设计有两重缺陷：它只能对初始的 collection view 的可见元素制作动画，因为<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/uiview_class/UIView/UIView.html#//apple_ref/doc/uid/TP40006816-CH3-SW198">快照 APIs </a> 只能工作于屏幕上可见的 view，另外，依赖于可见的元素数量，可能会有很多的 views 需要进行正确的跟踪并为其制作动画。但另一方面，这种设计又具有一个明显的优势，那就是它可以为所有类型的 <code>UICollectionViewLayout</code> 组合所使用。这样一个系统的实现就留给读者们去进行练习吧。</p>

<p>在附带的演示项目中我们用另一种途径进行了实现，它依赖于一些 <code>UICollectionViewFlowLayout</code> 的巧合。</p>

<p>基本的想法是，因为源 collection view 和目标 collection view 都拥有有效的 flow layouts，因此源 layout 的布局属性正好可以用作目标 collection view 的布局中的初始布局属性，以此驱动转场动画。一旦正确建立，就算对于那些一开始在屏幕上不可见的元素，collection view 的机制都将为我们追踪它们并进行动画。下面是我们的动画控制器中的 <code>animateTransition:</code> 的核心代码：</p>

<pre><code>    CGRect initialRect = [inView.window convertRect:_fromCollectionView.frame fromView:_fromCollectionView.superview];
    CGRect finalRect   = [transitionContext finalFrameForViewController:toVC];

    UICollectionViewFlowLayout *toLayout = (UICollectionViewFlowLayout*) _toCollectionView.collectionViewLayout;

    UICollectionViewFlowLayout *currentLayout = (UICollectionViewFlowLayout*) _fromCollectionView.collectionViewLayout;

    //制作原来布局的拷贝
    UICollectionViewFlowLayout *currentLayoutCopy = [[UICollectionViewFlowLayout alloc] init];

    currentLayoutCopy.itemSize = currentLayout.itemSize;
    currentLayoutCopy.sectionInset = currentLayout.sectionInset;
    currentLayoutCopy.minimumLineSpacing = currentLayout.minimumLineSpacing;
    currentLayoutCopy.minimumInteritemSpacing = currentLayout.minimumInteritemSpacing;
    currentLayoutCopy.scrollDirection = currentLayout.scrollDirection;

    //将拷贝赋值给源 collection view
    [self.fromCollectionView setCollectionViewLayout:currentLayoutCopy animated:NO];

    UIEdgeInsets contentInset = _toCollectionView.contentInset;

    CGFloat oldBottomInset = contentInset.bottom;

    //强制在目标 collection view 中设定一个很大的 bottom inset
    contentInset.bottom = CGRectGetHeight(finalRect)-(toLayout.itemSize.height+toLayout.sectionInset.bottom+toLayout.sectionInset.top);
    self.toCollectionView.contentInset = contentInset;

    //将源布局设置给目标 collection view
    [self.toCollectionView setCollectionViewLayout:currentLayout animated:NO];

    toView.frame = initialRect;

    [inView insertSubview:toView aboveSubview:fromView];

    [UIView
     animateWithDuration:[self transitionDuration:transitionContext]
     delay:0
     options:UIViewAnimationOptionBeginFromCurrentState
     animations:^{
       //使用最终 frame 制作动画
         toView.frame = finalRect;
         //在 performUpdates 中设定最终的布局
         [_toCollectionView
          performBatchUpdates:^{
              [_toCollectionView setCollectionViewLayout:toLayout animated:NO];
          }
          completion:^(BOOL finished) {
              _toCollectionView.contentInset = UIEdgeInsetsMake(contentInset.top,
                                                                contentInset.left,
                                                                oldBottomInset,
                                                                contentInset.right);
          }];

     } completion:^(BOOL finished) {
         [transitionContext completeTransition:YES];
     }];
</code></pre>

<p>首先，动画控制器确保目标 collection view 以与原来的 collection view 完全相同的框架和布局作为开始。接着，它将源 collection view 的布局设定给目标 collection view，以确保其不会失效。与此同时，该布局已经复制到另一个新的布局对象中，而这个布局对象则是为防止在导航回原始视图控制器时出现奇怪的布局 bug。我们还会强制在目标 collection view 的底部设定一个很大的 content inset，来确保布局在动画的初始位置时保持在一行上。观察日志的话，你会发现由于元素的尺寸加上 inset 的尺寸会比 collection view 的非滚动维度要大，因此 collection view 会在控制台警告。在这样的情况下，collection view 的行为是没有定义的，我们也只是使用这样一个不稳定的状态来作为我们转换动画的初始状态。最后，复杂的动画 block 将展现它的魅力，首先将目标 collection view 的框架设定到最终位置，然后在 <code>performBatchUpdates:completion:</code> 的 update block 中执行一个无动画的布局来改变至最终布局，紧随其后便是在 completion block 中将 content insets 重置为原始值。</p>

<h3>小结</h3>

<p>我们讨论了两种可以在 collection view 之间实现布局转场的途径。一种使用了内置的 <code>useLayoutToLayoutNavigationTransitions</code>，看起来令人印象深刻并且极其容易实现，缺点就是可以使用的范围较为局限。由于 <code>useLayoutToLayoutNavigationTransitions</code> 在一些案例中不能使用，想驱动自定义的过渡动画的话，就需要一个自定义的 animator。这篇文章中，我们看到了如何实现这样一个 animator，然而，由于你的应用程序大概肯定会需要在两个和本例完全不同的 view 结构中实现完全不同的动画，所以正如此例中做的那样，不要吝于尝试不同的方法来探究其是否能够工作。</p>

<hr />

<p><a href="http://objccn.io/issue-12">话题 #12 下的更多文章</a></p>

<p>原文 <a href="http://www.objc.io/issue-12/collectionview-animations.html">Animating Collection Views</a></p>


  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2014/05/10/issue-8-3-weekwood/">objc.io #issue8 导航应用[翻译]</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2014-05-10T09:56:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> May 10<span>th</span>, 2014</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2014/05/10/issue-8-3-weekwood/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




  <p>在这篇文章中，我们将把前面提到过的内容组织起来构成我们的导航器应用，这个 iPhone 应用将装载在我们的的无人机上，你可以在 <a href="https://github.com/objcio/issue-8-quadcopter-navigator">Github</a> 下载应用的源码，尽管这个应用是计划在没有直接的交互操作下来使用的，但在测试过程中我们做了一个简单的 UI 界面来显示其无人机状态并方便我们手动操作。</p>

<h2>概要</h2>

<p>在我们的应用中，我们有几个类它们分别是:</p>

<ul>
<li><p><code>DroneCommunicator</code> 这个类关注于利用 UDP 和无人机通讯。这个话题全部在 <a href="http://objccn.io/issue-8-2">Daniel 的文章</a>中详细介绍过</p></li>
<li><p><code>RemoteClient</code> 使用 <a href="https://developer.apple.com/library/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/_index.html">Multipeer Connectivity</a> 技术和我们的远程客户端进行交互，具体客户端的操作，请看 <a href="http://objccn.io/issue-8-4">Florian 的文章</a>。</p></li>
<li><code>Navigator</code> 用来设定目标位置，计算飞行航线，以及飞行距离。</li>
<li><code>DroneController</code> 用来把从 <code>Navigator</code> 获取的导航的距离和方向发送命令到<code>DroneCommunicator</code>。</li>
<li><code>ViewController</code> 有一个简单的界面，用来初始化其他的类并把它们连接起来，这部分应该用不同的类来完成，但是在我们的设想中，我们的app足够简单所以放到一个类就可以了。</li>
</ul>


<h2>View Controller</h2>

<p>View Controller 中最重要的一个部分是初始化方法，在这里我们创建了 <code>DroneCommunicator</code>， <code>Navigator</code>， <code>DroneController</code> 以及<code>RemoteClient</code> 的实例化对象，换句话说：我们建立了无人机和我们的客户端应用沟通的整个桥梁。</p>

<pre><code>- (void)setup
{
    self.communicator = [[DroneCommunicator alloc] init];
    [self.communicator setupDefaults];

    self.navigator = [[Navigator alloc] init];
    self.droneController = [[DroneController alloc] initWithCommunicator:self.communicator navigator:self.navigator];
    self.droneController.delegate = self;
    self.remoteClient = [[RemoteClient alloc] init];
    [self.remoteClient startBrowsing];
    self.remoteClient.delegate = self;
}
</code></pre>

<p>View Controller 同时是 <code>RemoteClient</code> 的委托。 这就说明无论我们的客户端发送了一个新位置或者着陆，重置以及关机的命令，我们都需要在这里处理它。举个例子，当我们收到一个新的位置的命令的时候，我们这样来做:</p>

<pre><code>- (void)remoteClient:(RemoteClient *)client didReceiveTargetLocation:(CLLocation *)location
    {
        self.droneController.droneActivity = DroneActivityFlyToTarget;
        self.navigator.targetLocation = location;
    }
</code></pre>

<p>这段代码是用来确保无人机开始飞行（而不是徘徊）并且更新目标位置。</p>

<h2>Navigator</h2>

<p>导航类用来指定目标位置，并且计算从当前位置到目标位置的距离，为了完成整个工作我们首先需要监听 core location 的改变：</p>

<pre><code>- (void)startCoreLocation
{
    self.locationManager = [[CLLocationManager alloc] init];
    self.locationManager.delegate = self;

    self.locationManager.distanceFilter = kCLDistanceFilterNone;
    self.locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation;
    [self.locationManager startUpdatingLocation];
    [self.locationManager startUpdatingHeading];
}
</code></pre>

<p>在我们的导航类中，我们有两种方向，绝对和相对方向，绝对方向是两个地点之间的方向。比如说，阿姆斯特丹和柏林间的绝对方向几乎处于同一纬度，相对位置则是我们在参考指南针后可以得出的路线方向，要从阿姆斯特丹一直向东到柏林，两地之间的相对方向为零。在操作无人机的时候我们就需要使用相对方向。方向值为零，飞机直行；方向角度小于零，飞机向右倾斜转弯；方向角度大于零，飞机则向左倾斜转弯。</p>

<p>计算到目的地的绝对方向，我们需要创建一个基于 <code>CLLocation</code> 的Helper方法用来计算两个点的方向:</p>

<pre><code>- (OBJDirection *)directionToLocation:(CLLocation *)otherLocation;
{
    return [[OBJDirection alloc] initWithFromLocation:self toLocation:otherLocation];
}
</code></pre>

<p>由于我们的无人机只能飞很小的距离（电池只能支持10分钟），所以我们需要一个几何的假设，我们是在一个平面而不是在地球表面:</p>

<pre><code>- (double)heading;
{
    double y = self.toLocation.coordinate.longitude - self.fromLocation.coordinate.longitude;
    double x = self.toLocation.coordinate.latitude - self.fromLocation.coordinate.latitude;

    double degree = radiansToDegrees(atan2(y, x));
    return fmod(degree + 360., 360.);
}
</code></pre>

<p>在导航器中，我们将得到位置和航向的回调，然后我们把这两个值存到属性中，比如，计算我们需要飞行的两点之间的距离，我们需要将绝对航向减去当前航向（这与你看到指南针上的值是一样的意思），然后将结果换算到 -180 度和 180  度之间。如果你希望知道为什么我们要减去 90 度，那是因为我们 iPhone 和无人机之间有 90 度的夹角。</p>

<pre><code>- (CLLocationDirection)directionDifferenceToTarget;
{
    CLLocationDirection result = (self.direction.heading - self.lastKnownSelfHeading.trueHeading - 90);
    // Make sure the result is in the range -180 -&gt; 180
    result = fmod(result + 180. + 360., 360.) - 180.;
    return result;
}
</code></pre>

<p>这就是我们导航做的事情。基于当前的位置和航向，计算出到目标的距离和无人机应当飞行的方向。并且监听这两个属性。</p>

<h2>Drone Controller</h2>

<p>Drone controller 用来初始化 navigator 和 communicator，并且发送距离和方向的命令到无人机，因为命令需要持续发送，所以我们创建一个计时器：</p>

<pre><code>self.updateTimer = [NSTimer scheduledTimerWithTimeInterval:0.25
                                                    target:self
                                                  selector:@selector(updateTimerFired:)
                                                  userInfo:nil
                                                   repeats:YES];
</code></pre>

<p>当计时器触发后，假设我们飞向一个目标，我们需要发送给无人机适当的指令，如果我们足够近，无人机盘旋，否则，我们转向目标，在大致方向正确的情况下飞过去！</p>

<pre><code>- (void)updateDroneCommands;
{
    if (self.navigator.distanceToTarget &lt; 1) {
        self.droneActivity = DroneActivityHover;
    } else {
        static double const rotationSpeedScale = 0.01;
        self.communicator.rotationSpeed = self.navigator.directionDifferenceToTarget * rotationSpeedScale;
        BOOL roughlyInRightDirection = fabs(self.navigator.directionDifferenceToTarget) &lt; 45.;
        self.communicator.forwardSpeed = roughlyInRightDirection ? 0.2 : 0;
    }
}
</code></pre>

<h2>Remote Client</h2>

<p>Remote Client 类关注于和我们的<a href="http://objccn.io/issue-8-4">客户端通讯</a>，我们利用了一个很方便 <a href="https://developer.apple.com/library/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/_index.html">Multipeer Connectivity 框架</a>。首先，我们需要和附近的创建一个会话以及 <code>MCNearbyServiceBrowser</code> :</p>

<pre><code>- (void)startBrowsing
{
    MCPeerID* peerId = [[MCPeerID alloc] initWithDisplayName:@"Drone"];

    self.browser = [[MCNearbyServiceBrowser alloc] initWithPeer:peerId serviceType:@"loc-broadcaster"];
    self.browser.delegate = self;
    [self.browser startBrowsingForPeers];

    self.session = [[MCSession alloc] initWithPeer:peerId];
    self.session.delegate = self;
}
</code></pre>

<p>在我们的项目中，我们不需要处理单独设备的安全问题，因为我们总是邀请所有的对等网络的设备。</p>

<pre><code>- (void)browser:(MCNearbyServiceBrowser *)browser foundPeer:(MCPeerID *)peerID withDiscoveryInfo:(NSDictionary *)info
{
    [browser invitePeer:peerID toSession:self.session withContext:nil timeout:0];
}
</code></pre>

<p>我们需要加入 <code>MCNearbyServiceBrowserDelegate</code> 和 <code>MCSessionDelegate</code> 全部的协议方法，否则这个应用将会崩溃。唯一一个方法我们需要实现的是 <code>session:didReceiveData:fromPeer:</code> 。我们解析对等客户端发送来的命令并且调用合适的委托方法，在我们简易的应用中，View Controller 实现了这些委托，当我们接收到了新的位置我们更新导航，并且让无人机飞向新的位置。</p>

<h2>总结</h2>

<p>这篇文章描述了这个简易的 app ，最初我们把所有的委托和代码都加入到了 View Controller 中，这是被证明最简单的编码和测试方式，其实写代码是一个容易的事情，但是阅读代码非常困难。因此我们需要重构所有的代码让其合理的分配到不同类中。</p>

<p>硬件方面的工作，测试非常的耗时，比如，在我们的 quadcopter 项目中，需要一段时间来启动设备，发送命令，并让它飞起来。因此我们尽可能多在离线状况下测试。我们还添加了大量的的日志语句，这样我们调试起来更加方便。</p>

<p><a href="http://objccn.io/issue-8">话题 #8 下的更多文章</a></p>

<p>原文 <a href="http://www.objc.io/issue-8/the-quadcopter-navigator-app.html">The Navigator App</a></p>


  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2014/05/10/issue-8-2-weekwood/">objc.io #issue 8 与四轴无人机的通讯[翻译]</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2014-05-10T09:56:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> May 10<span>th</span>, 2014</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2014/05/10/issue-8-2-weekwood/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




  <p><a href="http://ardrone2.parrot.com/">AR Drone</a> <a href="https://en.wikipedia.org/wiki/Quadcopter">无人机</a>是一台小型的 Linux，当我们加入它提供的 WiFi 热点的时候，我们就可以通过 192.168.1.1 来访问无人机。</p>

<h2>用户数据报协议（UDP）</h2>

<p>无人机的通讯采用了 <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP 协议</a>，UDP 是至今沿用并占有主导地位的<a href="https://en.wikipedia.org/wiki/Transport_layer">传输层</a>协议之一，而另一个是 TCP 协议。</p>

<p>我们暂且先聊聊 TCP 协议，或者我们称之为<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">传输控制协议</a>，基于它操作和使用起来极其方便，现在几乎所有的网络连接都是通过 TCP 来完成。 使用 TCP 协议的 API 非常直截了当，当你需要从一个设备传输数据到另一个硬件设备的时候，TCP 可以被所有硬件设备支持。使用 TCP 有多简单？一旦建立连接，你把数据写入 socket，另一台设备将从 socket 读取数据，TCP 会确保数据正确的写入并且传输给另一个设备。 许多复杂的细节隐匿其中。TCP 是基于 IP 层之上的，所有低级 IP 数据都不能按照其发送的顺序到达，事实上，甚至有可能永远都等不到它。但是 TCP 隐藏了这个玄机，它在 Unix 管道上建模，TCP 同时也管理着吞吐量；它不断的适应并达到最大的带宽利用率。它似乎确实有着神奇的魔力可以变出三册总页数超过2556页的书来阐述它的魅力。 TCP/IP Illustrated: <a href="http://www.amazon.com/dp/0321336313">The Protocols</a>，<a href="http://www.amazon.com/dp/020163354X">The Implementation</a>, <a href="http://www.amazon.com/dp/0201634953">TCP for Transactions</a>。</p>

<p>UDP，是传输层的另一个重要组成部分，也是一个相对简单的协议，但是使用 UDP 对开发者来说很痛苦，当你通过 UDP 发送数据的时候，无法得知数据是否成功被接收，也不知道数据到达的顺序，同样得不到（在不被带宽变化影响而丢失数据的情况下）我们发送数据可达的最大速度。</p>

<p>就是说，UDP 是一个非常简单的模型：UDP 允许你在设备之间发送所谓的数据包。这些数据包 (分组) 在另一端以同样格式的数据包被接收（除非他们已经在路上消失了）。</p>

<p>为了使用 UDP，一个应用需要使用<a href="https://en.wikipedia.org/wiki/Datagram_socket">数据报 socket</a>，它在通讯两端绑定了一个 IP 地址和<a href="https://en.wikipedia.org/wiki/Port_number">服务端口</a>，并且因此建立了一个主机到主机的通讯，发送数据给一个指定的 socket 可以从匹配的另一端 socket 接收。</p>

<p>注意，UDP 是一个无连接协议，这里不需要设置连接，socket 对从哪里发送数据和数据何时到达进行简单的跟踪，当然，建立在数据能够被 socket 捕捉的基础上。</p>

<h2>UDP 以及 AR DRONE</h2>

<p>AR Drone 的接口建立在三个 UDP 端口上， 通过上面的讨论我们知道 UDP 是一个还有待讨论的设计方案，但是 <a href="http://www.parrot.com/usa/">Parrot</a> 选择了去实现它。</p>

<p>无人机的 IP 地址是 192.168.1.1， 并且这里有三个端口我们可以用来连接 UDP</p>

<p>导航控制数据端口 = 5554</p>

<p>机载视频端口 = 5555</p>

<p>AT 指令端口 = 5556</p>

<p>我们需要利用 <em>AT 指令集端口</em>来发送命令到无人机，用导航数据端口来接收无人机返回的数据。其工作原理完全不同，因此只能分开讨论两者，即便如此，它们都依赖于 UDP socket 的。我们来看看这是如何实现的。</p>

<h2>UDP API</h2>

<p>首先非常奇怪的是，Apple 没有为 UDP 的运行提供 Objective-C helper 封装。毕竟，这个协议甚至可以追溯到 1980 年，主因是几乎没有使用 UDP 的应用，如果我们使用 UDP，至少访问 UDP 的 Unix C API 将成为我们担忧的一部分。因此大多数情况下我们会使用 TCP，而且对其来说，有很多 API 可供选择。
C 语言的 API 我们使用了高级研究计划署（发明互联网的地方）定义在 <code>sys/socket.h</code>，<code>netinet/in.h</code>，<code>arpa/inet.h</code> 的方法。</p>

<h2>创建 UDP socket</h2>

<p>首先，用下面的语句来创建 socket</p>

<pre><code>int nativeSocket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
</code></pre>

<p><code>PF_INET</code> 是 socket 的域名，在这个例子中是互联网，<code>SOCK_DGRAM</code> 定义了数据报的格式（相对于流式套接字）。最后，<code>IPPROTO_UDP</code> 定义了传输协议 UDP。socket 的工作方式类似于调用 <a href="http://man7.org/linux/man-pages/man2/open.2.html">open(2) 方法</a></p>

<p>接下来，我们创建了一个结构体，包括我们的地址和无人机的地址，结构体中的 <code>sockaddr_in</code> 是套接字的地址，我们使用 <code>sin_me</code> 来定义自己的地址，以及 <code>sin_other</code> 来定义另一端的地址</p>

<pre><code>struct sockaddr_in sin_me = {};
sin_me.sin_len = (__uint8_t) sizeof(sin);
sin_me.sin_family = AF_INET;
sin_me.sin_port = htons(0);
sin_me.sin_addr.s_addr = htonl(INADDR_ANY);

struct sockaddr_in sin_other = {};
sin_other.sin_len = (__uint8_t) sizeof(sin_other);
sin_other.sin_family = AF_INET;
sin_other.sin_port = htons(self.port);
int r = inet_aton([self.address UTF8String], &amp;sin_other.sin_addr)
</code></pre>

<p>用 <code>={}</code> 来初始化结构体总体来说是一个最佳实践，可以不用考虑你使用什么结构，因为它确保一切开始时为零的。否则这些值无论在堆栈上的任何情况下都将是不确定的，我们会很容易碰到奇怪而又少见的 bug。</p>

<p>接下来，我们要给 <code>sockaddr_in</code> 赋值，并且指定 <code>sin_len</code> 来让其可用，这样允许多个地址，<code>sin_family</code> 就是地址类型的一种。有一种一长串的地址协议簇，当我们通过 internet 连接时候，总是用 <a href="https://en.wikipedia.org/wiki/Ipv4">IPv4</a> 的 <code>AF_INET</code> 或者<a href="https://en.wikipedia.org/wiki/Ipv6">IPv6</a> 的 <code>AF_INET6</code>，然后我们设置端口和 <code>IP</code> 地址。</p>

<p>在我们这边，我们指定端口为 0，并且地址是 <code>INADDR_ANY</code>，0 端口意思是一个随机的端口将会分配给我们的设备。 <code>INADDR_ANY</code> 则可以导入传送路由数据包到另一端的地址（无人机）。</p>

<p>无人机的地址指定为 <code>inet_aton(3)</code>, 它将转换 C 字符串 192.168.1.1 成相应的四字节 0xc0, 0xa2, 0x1, 0x1 - 作为无人机的IP地址。注意我们我们对地址和端口号调用了 <code>htons(3)</code> 和 <code>htonl(3)</code>。htons 是 host-to-network-short 的缩写，htonl 是 host-to-network-long 的缩写。 大多数数据网络 (包括 IP) 是<a href="https://en.wikipedia.org/wiki/Endianness">字节序</a>是使用大端序 (big-endian)。为了确保数据按照正确的字节序发送我们需要调用这两个功能。</p>

<p>现在我们绑定 socket 到我们的 socket 地址。</p>

<pre><code>int r2 = bind(nativeSocket, (struct sockaddr *) &amp;sin_me, sizeof(sin_me));
</code></pre>

<p>最后,我们通过下面的 socket 连到另一端 socket 地址:</p>

<pre><code>int r3 = connect(nativeSocket, (struct sockaddr *) &amp;sin_other, sizeof(sin_other));
</code></pre>

<p>最后一步是可选的，在每次发送数据包的时候我们也可以指定目的地址。</p>

<p>在我们示例代码中，这是在 <code>-[DatagramSocket configureIPv4WithError:]</code> 方法中实现的，这个方法同时还进行了一些错误处理的操作。</p>

<h2>发送数据</h2>

<p>当我们有一个可用的 socket 时，发送数据就很简单了。比如我们要发送一个叫做 <code>data</code> 的 <code>NSData</code> 对象时，我们需要调用：</p>

<pre><code>ssize_t const result = sendto(nativeSocket, [data bytes], data.length, 0, NULL, 0);
if (result &lt; 0) {
    NSLog(@"sendto() failed: %s (%d)", strerror(errno), errno);
} else if (result != data.length) {
    NSLog(@"sendto() failed to send all bytes. Sent %ld of %lu bytes.", result, (unsigned long) data.length);
}
</code></pre>

<p>注意，<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a> 从设计的上就是不可靠的，一旦调用 <code>sendto(2)</code>，接下来网上数据传输过程就不是我们可以控制的了。</p>

<h2>接收数据</h2>

<p>接收数据的核心非常简单，这个方法叫做 <code>recvfrom(2)</code>， 包括两个参数，第一个是 <code>sin_other</code> 指定了我们希望接受的数据的发送方，第二个参数是指向一个缓冲区的指针，的数据将被写入其中。如果成功，这个方法返回读取的字节数：</p>

<pre><code>NSMutableData *data  = [NSMutableData dataWithLength:65535];
ssize_t count = recvfrom(nativeSocket, [data mutableBytes], [data length], 0, (struct sockaddr *) &amp;sin_other, &amp;length);
if (count &lt; 0) {
    NSLog(@"recvfrom() failed: %s (%d)", strerror(errno), errno);
    data = nil;
} else {
    data.length = count;
}
</code></pre>

<p>一个值得注意的事情， <code>recvfrom(2)</code> 是一个阻塞方法，线程一旦调用这个方法，则会等待直到数据全部读完。正常情况下这都不是我们想要的。运用 <a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref">GCD</a>，我们可以设置一个事件源，每当 socket 有要读取的数据它都能进行初始化。对于读取来自 socket 的数据来说这是一个推荐的做法。</p>

<p>在我们的例子中，<code>DatagramSocket</code> 类运用了这个方法来设置事件源：</p>

<pre><code>- (void)createReadSource
{
    self.readEventSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, self.nativeSocket, 0, self.readEventQueue);
    __weak DatagramSocket *weakSelf = self;
    dispatch_source_set_event_handler(self.readEventSource, ^{
        [weakSelf socketHasBytesAvailable];
    });
    dispatch_resume(self.readEventSource);
}
</code></pre>

<p>数据源开始时处于暂停状态，这就是为什么我们必须使用 <code>dispatch_resume(3)</code>。 否则，将不会有事件传到数据源，<code>-socketHasBytesAvailable</code> 之后会对 <code>recvfrom(2)</code> 进行调用。</p>

<h2>默认值</h2>

<p>为了避免一个小问题，我们要重写 <code>nativeSocket</code> 的属性方法。</p>

<pre><code>@property (nonatomic) int nativeSocket;
</code></pre>

<p>这样来实现</p>

<pre><code>@synthesize nativeSocket = _nativeSocket;
- (void)setNativeSocket:(int)nativeSocket;
{
    _nativeSocket = nativeSocket + 1;
}

- (int)nativeSocket
{
    return _nativeSocket - 1;
}
</code></pre>

<p>我们从内部的实例变量里减 1，首先因为 Objective-C 运行时保证在调用 <code>-alloc</code> 后所有实例变量初始值 0。其次，socket 只要为非负就被认为是有效的，比如大于 0 的均为有效的 socket 数字。</p>

<p>通过这样的偏移，即使 <code>-init</code> 没有被调用，我们仍然可以安全地检查 socket 值是否已经被设定。</p>

<h2>整合在一起</h2>

<p>在 <a href="https://github.com/objcio/issue-8-quadcopter-navigator/blob/master/DatagramSocket.m">DatagramSocket 类</a> 中我们封装了所有低级的 UDP socket 的工作。DroneCommunicator 类用来和无人机的<em>导航数据端口 5554</em> 和 <em>AT 指令集端口 5556</em> 的通讯，就像这样：</p>

<pre><code>NSError *error = nil;
self.commandSocket = [DatagramSocket ipv4socketWithAddress:DroneAddress
                                                      port:ATCommandPort
                                           receiveDelegate:self
                                              receiveQueue:[NSOperationQueue mainQueue]
                                                     error:&amp;error];

self.navigationDataSocket = [DatagramSocket ipv4socketWithAddress:DroneAddress
                                                             port:NavigationDataPort
                                                  receiveDelegate:self
                                                     receiveQueue:[NSOperationQueue mainQueue]
                                                            error:&amp;error];
</code></pre>

<p>委托方法基于 socket 实现</p>

<pre><code>- (void)datagramSocket:(DatagramSocket *)datagramSocket didReceiveData:(NSData *)data;
{
    if (datagramSocket == self.navigationDataSocket) {
        [self didReceiveNavigationData:data];
    } else if (datagramSocket == self.commandSocket) {
        [self didReceiveCommandResponseData:data];
    }
}
</code></pre>

<p>在我们的示例 app 里需要处理的只有导航数据，它被 <code>DroneNavigationState</code> 处理：</p>

<pre><code>- (void)didReceiveNavigationData:(NSData *)data;
{
    DroneNavigationState *state = [DroneNavigationState stateFromNavigationData:data];
    if (state != nil) {
        self.navigationState = state;
    }
}
</code></pre>

<h2>发送命令</h2>

<p>当 UDP socket 创建并运行后，发送的命令相对来说很很直接了。所谓的命令端口接受可以纯 ASCII 命令， 看起来就像这样：</p>

<pre><code>AT*CONFIG=1,"general:navdata_demo","FALSE"
AT*CONFIG=2,"control:altitude_max","1600"
AT*CONFIG=3,"control:flying_mode","1000"
AT*COMWDG=4
AT*FTRIM=5
</code></pre>

<p><a href="https://projects.ardrone.org/projects/show/ardrone-api">AR Drone SDK</a> 包含了一个叫做 <em>ARDrone Developer Guide</em> 的 PDF 文档，里面详细介绍了所有的AT指令集。</p>

<p>我们在 <code>DroneCommunicator</code> 类中创造了一系列 helper 方法，使上述可以被发送：</p>

<pre><code>[self setConfigurationKey:@"general:navdata_demo" toString:@"FALSE"];
[self setConfigurationKey:@"control:altitude_max" toString:@"1600"];
[self setConfigurationKey:@"control:flying_mode" toString:@"1000"];
[self sendCommand:@"COMWDG" arguments:nil];
[self sendCommand:@"FTRIM" arguments:nil];
</code></pre>

<p>所有的无人机指令以 AT* 开头，跟着加上指令名以及 =，然后是被逗号隔开的参数，第一个参数是命令的序列号。</p>

<p>为了方便使用，这里我们创建了一个叫做 <code>-sendCommand:arguments:</code> 的方法，它会在索引的开始 (index 0) 的地方插入命令序列号</p>

<pre><code>- (int)sendCommand:(NSString *)command arguments:(NSArray *)arguments;
{
    NSMutableArray *args2 = [NSMutableArray arrayWithArray:arguments];
    self.commandSequence++;
    NSString *seq = [NSString stringWithFormat:@"%d", self.commandSequence];
    [args2 insertObject:seq atIndex:0];
    [self sendCommandWithoutSequenceNumber:command arguments:args2];
    return self.commandSequence;
}
</code></pre>

<p>这里调用了 <code>-sendCommandWithoutSequenceNumber:arguments:</code>，这个方法加上了 AT* 前缀并且将命令和参数串接起来：</p>

<pre><code>- (void)sendCommandWithoutSequenceNumber:(NSString *)command arguments:(NSArray *)arguments;
{
    NSMutableString *atString = [NSMutableString stringWithString:@"AT*"];
    [atString appendString:command];
    NSArray* processedArgs = [arguments valueForKey:@"description"];
    if (0 &lt; arguments.count) {
        [atString appendString:@"="];
        [atString appendString:[processedArgs componentsJoinedByString:@","]];
    }
    [atString appendString:@"\r"];
    [self sendString:atString];
}
</code></pre>

<p>最后，将完成的字符串转换为 NSData 并且传给 socket：</p>

<pre><code>- (void)sendString:(NSString*)string
{
    NSData *data = [string dataUsingEncoding:NSASCIIStringEncoding];
    if (data != nil) {
        [self.commandSocket asynchronouslySendData:data];
    } else {
        NSLog(@"Unable to convert string to ASCII: %@", string);
    }
}
</code></pre>

<h2>浮点字符串编码</h2>

<p>因为一些奇怪的原因，设计无人机协议的人规定了浮点值应当作为具有相同位模式的整数来发送。这确实蛮奇怪的，但我们只能遵守协议。</p>

<p>比如说我们需要让无人机的前进的相对速度是 0.5，浮点数 0.5 在二进制看起来是：</p>

<pre><code>0011 1111 0000 0000 0000 0000 0000 0000
</code></pre>

<p>我们在 32 位整形中重新解释这个数的话，它是 1056964608，所以我们发送到无人机的命令是：</p>

<pre><code>AT*PCMD=6,1,0,1056964608,0,0 
</code></pre>

<p>在我们的例子中，我们用一个 <code>NSNumber</code> 的封装来完成，这个代码最终看起来像：</p>

<pre><code>NSNumber *number = (id) self.flightState[i];
union {
    float f;
    int i;
} u;
u.f = number.floatValue;
[result addObject:@(u.i)];
</code></pre>

<p>这里的技巧是使用 union - C 语言的一个鲜为人知的部分。union 允许多个不同的类型（在这种情况下，是整数和浮点型）驻留在同一存储区域。然后，我们将浮点值存储到 u.f 并从 u.i 读取整数值。</p>

<p>注意：使用像 <code>int i = *((int *) &amp;f)</code> 这样的代码是不合法的，这不是正确的 C 代码，并且会导致未定义的行为。生成的代码有时会工作，但有时候不会。所以不要做无谓的尝试。你可以通过多阅读 <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">llvm 博客</a>中 <em>Violating Type Rules</em> 下的文章来了解更多。悲剧的是 <em>AR Drone Developer Guide</em> 就是把这里弄错了。</p>

<hr />

<p><a href="http://objccn.io/issue-8">话题 #8 下的更多文章</a></p>

<p>原文 <a href="http://www.objc.io/issue-8/communicating-with-the-quadcopter.html">Communicating with the Quadcopter</a></p>


  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2013/09/24/7-tips-for-a-node-dot-js-padawan/">7 tips for a Node.js padawan</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2013-09-24T14:52:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Sep 24<span>th</span>, 2013</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2013/09/24/7-tips-for-a-node-dot-js-padawan/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




<div class="entry-content clearfix">
  <h2>一些我更愿意在开始就知道东西</h2>

<p>利用 Node.js 开发是一个非常有趣,和令人满足的过程, 他有3万多个模块可以选择使用,并且所有的模块可以非常容易的集成入现有的应用之中.</p>

<p>无论如何,对于一些刚开始使用Node.js 开发的的人来说, 很容易碰壁,在这个文章中,我会提到在你学习过程中遇到的问题.</p>


  <a class="btn pull-right" href="/2013/09/24/7-tips-for-a-node-dot-js-padawan/">Read on</a>
</div>

  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2013/09/23/ios7jie-mian-guo-du/">iOS7 兼容适配</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2013-09-23T22:18:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Sep 23<span>rd</span>, 2013</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2013/09/23/ios7jie-mian-guo-du/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




<div class="entry-content clearfix">
  <h3>如何判断版本号</h3>

<p>很多时候我们需要做不同版本的适配,所以首先要进行版本选择</p>

<ul>
<li>方式一</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSUInteger</span> <span class="n">DeviceSystemMajorVersion</span><span class="p">();</span>
</span><span class='line'><span class="n">NSUInteger</span> <span class="nf">DeviceSystemMajorVersion</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">static</span> <span class="n">NSUInteger</span> <span class="n">_deviceSystemMajorVersion</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'>      <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>       <span class="n">_deviceSystemMajorVersion</span> <span class="o">=</span> <span class="p">[[[[[</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">systemVersion</span><span class="p">]</span>
</span><span class='line'>           <span class="nl">componentsSeparatedByString:</span><span class="s">@&quot;.&quot;</span><span class="p">]</span> <span class="nl">objectAtIndex:</span><span class="mi">0</span><span class="p">]</span> <span class="n">intValue</span><span class="p">];</span>
</span><span class='line'>      <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">return</span> <span class="n">_deviceSystemMajorVersion</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="cp"> #define MY_MACRO_NAME (DeviceSystemMajorVersion() &lt; 7)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>





  <a class="btn pull-right" href="/2013/09/23/ios7jie-mian-guo-du/">Read on</a>
</div>

  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2013/08/11/objective-c-code-review/">Objective-c Code Review</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2013-08-11T12:14:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Aug 11<span>th</span>, 2013</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2013/08/11/objective-c-code-review/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




  <h3>参考资料</h3>

<p><a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/">Google Objective-C Style Guide 中文版</a></p>


  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2013/08/10/octopress-can-not-create-new-post-on-zsh/">Octopress Can not create new post on zsh</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2013-08-10T13:25:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Aug 10<span>th</span>, 2013</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2013/08/10/octopress-can-not-create-new-post-on-zsh/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




  <p>执行：$ rake new_post[&#8220;arch-linux-reinstall-glibc.markdown&#8221;]</p>

<p>报错：zsh: no matches found: new_post[arch-linux-reinstall-glibc]</p>

<p>原因：zsh中若出现‘*’, ‘(’, ‘|’, ‘&lt;’, ‘[’, or ‘?’符号，则将其识别为查找文件名的通配符</p>

<p>快速解决：用引号括起来$ rake &#8220;new_post[arch-linux-reinstall-glibc.markdown]&#8221;</p>

<p>彻底解决：取消zsh的通配(GLOB), 在.zshrc中加入alias rake=&#8221;noglob rake&#8221;</p>


  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2013/08/10/xcodeincrement-build-number/">XcodeIncrement build number</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2013-08-10T12:12:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Aug 10<span>th</span>, 2013</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2013/08/10/xcodeincrement-build-number/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




  

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if [ $CONFIGURATION == Release ]; then
</span><span class='line'>    echo "Bumping build number..."
</span><span class='line'>    plist=${PROJECT_DIR}/${INFOPLIST_FILE}
</span><span class='line'>
</span><span class='line'># increment the build number (ie 115 to 116)
</span><span class='line'>    buildnum=$(/usr/libexec/PlistBuddy -c "Print CFBundleVersion" "${plist}")
</span><span class='line'>    if [[ "${buildnum}" == "" ]]; then
</span><span class='line'>        echo "No build number in $plist"
</span><span class='line'>        exit 2
</span><span class='line'>    fi
</span><span class='line'>
</span><span class='line'>    buildnum=$(expr $buildnum + 1)
</span><span class='line'>    /usr/libexec/Plistbuddy -c "Set CFBundleVersion $buildnum" "${plist}"
</span><span class='line'>    echo "Bumped build number to $buildnum"
</span><span class='line'>
</span><span class='line'>else
</span><span class='line'>    echo $CONFIGURATION " build - Not bumping build number."
</span><span class='line'>fi</span></code></pre></td></tr></table></div></figure>



  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2013/03/13/hello-ruby-2/">&#8216;Hello Ruby 2 &#8211; Ruby 2.0安装&#8217;</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2013-03-13T17:00:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Mar 13<span>th</span>, 2013</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2013/03/13/hello-ruby-2/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




<div class="entry-content clearfix">
  <p>更新博客才发现因为换了硬盘的关系 <a href="http://octopress.org/">octopress</a> 不能使用了所以顺手更新下Ruby 2.0</p>

<p>使用了 <a href="https://rvm.io/">RVM</a> 以及 <a href="http://mxcl.github.com/homebrew/">Homebrew</a></p>

<p>首先,我们需要安装一些依赖库</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brew install autoconf
</span><span class='line'>$ brew install pkg-config
</span><span class='line'>$ brew install libyaml
</span><span class='line'>$ brew install readline
</span><span class='line'>$ brew install libxml2
</span><span class='line'>$ brew install libxslt</span></code></pre></td></tr></table></div></figure>





  <a class="btn pull-right" href="/2013/03/13/hello-ruby-2/">Read on</a>
</div>

  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2013/03/05/xcode-shortcuts/">Xcode shortcuts</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2013-03-05T23:00:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Mar 5<span>th</span>, 2013</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2013/03/05/xcode-shortcuts/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




<div class="entry-content clearfix">
  <p>换了机械键盘在享受打字快感的时候,也面临着难以控制触摸板的烦恼,也就是我整理快捷键的初衷.
善用快捷键是提升效率的有效方式.</p>

<p>⌘   (Command)</p>

<p>⌃   (Control)</p>

<p>⌥   (Option)</p>

<p>⇧   (Shift)</p>

<h3>全局搜索</h3>

<p>如果你只想学一个快捷键的话这个足以.</p>

<p>⌃ + ⌘ + /  - Search help</p>


  <a class="btn pull-right" href="/2013/03/05/xcode-shortcuts/">Read on</a>
</div>

  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2013/01/29/mobile-site-with-nginx/">mobile site with nginx</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2013-01-29T23:57:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Jan 29<span>th</span>, 2013</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2013/01/29/mobile-site-with-nginx/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




<div class="entry-content clearfix">
  <p>整理下如何利用nginx让移动终端用户访问mobile site.</p>

<p>需求类似如此:</p>

<ul>
<li>访问 <code>mysite.com</code> 或者 <code>www.mysite.com</code> 用户看到的是移动版本</li>
<li>提供从移动版本到原始版本的转换</li>
<li>可以轻松的返回移动版本</li>
<li>提供移动域名<code>m.mysite.com</code></li>
<li>可以在浏览器上测试移动版页面</li>
<li>提供cache支持</li>
<li>&#8230;</li>
</ul>



  <a class="btn pull-right" href="/2013/01/29/mobile-site-with-nginx/">Read on</a>
</div>

  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2013/01/27/yi-xie-cheng-xu-yuan-wang-zhan/">一些程序员网站</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2013-01-27T22:45:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Jan 27<span>th</span>, 2013</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2013/01/27/yi-xie-cheng-xu-yuan-wang-zhan/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




<div class="entry-content clearfix">
  <p>整理了下经常去的一些网站，一些参考吧。</p>

<h4><a href="https://github.com/">Github</a>:</h4>

<p>目前最活跃的开源社区,每天要花很多时间在这里浏览一些的东西,学习源码.</p>

<h4><a href="http://stackoverflow.com/">stackoverflow</a>:</h4>

<p>技术社区</p>

<h4><a href="http://www.raywenderlich.com/">raywenderlich</a>:</h4>

<p>有很多的iOS的教程，值得学习，网站可以购买<strong>《iOS 6 By Tutorials》</strong>版本书籍，很不错</p>


  <a class="btn pull-right" href="/2013/01/27/yi-xie-cheng-xu-yuan-wang-zhan/">Read on</a>
</div>

  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2013/01/14/about-cocoapods/">About CocoaPods</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2013-01-14T14:18:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Jan 14<span>th</span>, 2013</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2013/01/14/about-cocoapods/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




<div class="entry-content clearfix">
  <h3>什么是CocoaPods</h3>

<p>每个做iOS开发的人或多或少会用到一些开源的源代码。我想你们也会有何我一样的经历</p>

<ol>
<li>开源文件复制道项目中</li>
<li>添加依赖的系统库</li>
<li>手动管理依赖库更新</li>
</ol>


<p>这简直是地狱！也许你和我一样需要CocoaPods, 它是一个负责管理iOS第三方开源代码的工具。</p>

<p>我们不在需要执行这些事情仅仅</p>

<blockquote><p>$ pod install</p></blockquote>

<p>它会下载podfile 文件中的依赖库。</p>

<p>就是这么简单</p>


  <a class="btn pull-right" href="/2013/01/14/about-cocoapods/">Read on</a>
</div>

  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2013/01/11/arc-plus-blocks-plus-llvm4-de-shi-dai-2-slash-3/">Arc+blocks+llvm4 的时代2/3</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2013-01-11T14:10:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Jan 11<span>th</span>, 2013</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2013/01/11/arc-plus-blocks-plus-llvm4-de-shi-dai-2-slash-3/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




<div class="entry-content clearfix">
  <h1>Object Literals</h1>

<h3>NSNumber Literals</h3>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//NSNumber Creation</span>
</span><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
</span><span class='line'><span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithChar:</span><span class="sc">&#39;X&#39;</span><span class="p">];</span>
</span><span class='line'><span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithInt:</span><span class="mi">12345</span><span class="p">];</span>
</span><span class='line'><span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithUnsignedLong:</span><span class="mi">12345</span><span class="n">ul</span><span class="p">];</span>
</span><span class='line'><span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithLongLong:</span><span class="mi">12345l</span><span class="n">l</span><span class="p">];</span>
</span><span class='line'><span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="mf">123.45f</span><span class="p">];</span>
</span><span class='line'><span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithDouble:</span><span class="mf">123.45</span><span class="p">];</span>
</span><span class='line'><span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithBool:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//NSNumber Literals</span>
</span><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
</span><span class='line'><span class="n">value</span> <span class="o">=</span> <span class="sc">@&#39;X&#39;</span><span class="p">;</span>
</span><span class='line'><span class="n">value</span> <span class="o">=</span> <span class="err">@</span><span class="mi">12345</span><span class="p">;</span>
</span><span class='line'><span class="n">value</span> <span class="o">=</span> <span class="err">@</span><span class="mi">12345</span><span class="n">ul</span><span class="p">;</span>
</span><span class='line'><span class="n">value</span> <span class="o">=</span> <span class="err">@</span><span class="mi">12345l</span><span class="n">l</span><span class="p">;</span>
</span><span class='line'><span class="n">value</span> <span class="o">=</span> <span class="err">@</span><span class="mf">123.45f</span><span class="p">;</span>
</span><span class='line'><span class="n">value</span> <span class="o">=</span> <span class="err">@</span><span class="mf">123.45</span><span class="p">;</span>
</span><span class='line'><span class="n">value</span> <span class="o">=</span> <span class="err">@</span><span class="n">YES</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>





  <a class="btn pull-right" href="/2013/01/11/arc-plus-blocks-plus-llvm4-de-shi-dai-2-slash-3/">Read on</a>
</div>

  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2012/12/30/api-design-yi-wen/">API Design 译文</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2012-12-30T00:02:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Dec 30<span>th</span>, 2012</time>
    



  
  <div class="pull-left">
    <i class="icon-tags"></i>
    <ul class="tags unstyled">
    
      <li><a href="/blog/categories/API/">API</a></li>
    
      <li><a href="/blog/categories/ObjC/">ObjC</a></li>
    
    </ul>
  </div>
  

    
      <a class="pull-right" href="http://weekwood.github.com/2012/12/30/api-design-yi-wen/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




<div class="entry-content clearfix">
  <p>本文来源于<a href="http://mattgemmell.com/2012/05/24/api-design/">matt gemmell</a>困于自己英语水平问题， 若有错误见谅。</p>

<p>One of the development tasks I do most often is designing the API for a reusable component. The components are usually for iOS (though sometimes they’re for OS X), and are invariably GUI controls or views of some kind.</p>

<p>我最常做的工作之一就是设计可重用的组件，这些组件一般用于iOS（一些时候也用在OS X）的GUI控件或者某些视图上。</p>

<p>I’ve designed literally dozens of component APIs over the years, including for clients like Apple, and I’ve learned quite a bit about the process. I periodically release open source components too, and the feedback I’ve had has helped me put together a set of guidelines for API design that I’d like to share with you.</p>

<p>多年来我设计了几十个API组件都已经成功出现在了大家的视线里，比如一些苹果风格的客户端，并且我对这个开发过程有了一定的了解。我定期也会发布一些开源的组件，并且从中获得了很多反馈让我受益良多，与此同时我整理了一套API设计的指南，现在我将成果分享给大家。</p>


  <a class="btn pull-right" href="/2012/12/30/api-design-yi-wen/">Read on</a>
</div>

  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2012/12/24/arc-plus-blocks-plus-llvm4-shi-dai-1/">arc+blocks+llvm4 的时代1/3</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2012-12-24T14:56:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Dec 24<span>th</span>, 2012</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2012/12/24/arc-plus-blocks-plus-llvm4-shi-dai-1/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




<div class="entry-content clearfix">
  <h1>ARC</h1>

<p>ARC(Automatic Reference Counting) 到现在已经出来一年有余,越来越多的团队已经体会到他的好处。曾和同行们讨论过新手是否有必要深入学习手动内存管理。个人认为从arc开始的成本要低很多，而且能编译出强壮的代码，何乐不为？</p>


  <a class="btn pull-right" href="/2012/12/24/arc-plus-blocks-plus-llvm4-shi-dai-1/">Read on</a>
</div>

  </article>
  <hr>

  
  <article class="listing">
    <header>
  
  <h1 class="beta">
    <a href="/2012/12/23/regex-to-catch-at-mention-number-hashtag-and-link-http-s-slash-slash/">Regex to catch @mention #hashtag and link http(s)://</a>
  </h1>
  

  
  <div class="meta clearfix">
    








  


<time class="pull-left" datetime="2012-12-23T17:13:00+08:00" pubdate data-updated="true"><i class="icon-calendar"></i> Dec 23<span>rd</span>, 2012</time>
    



  

    
      <a class="pull-right" href="http://weekwood.github.com/2012/12/23/regex-to-catch-at-mention-number-hashtag-and-link-http-s-slash-slash/#disqus_thread">
        Comments <i class="icon-comment"></i>
      </a>
    
  </div>
  
</header>




<div class="entry-content clearfix">
  <p>在做tweet类文本的时候你需要解析以#开头的话题 @开头的昵称 http开头的连接
以下这个就是一个很好的例子(核心代码：<a href="https://github.com/SebastienThiebaud/STTweetLabel">STTweetLabel</a>)</p>


  <a class="btn pull-right" href="/2012/12/23/regex-to-catch-at-mention-number-hashtag-and-link-http-s-slash-slash/">Read on</a>
</div>

  </article>
  <hr>

        </div>
      </div>
      <div class="row-fluid">
        <footer class="footer-page" role="contentinfo">
          <p>
  Copyright &copy; 2014 - Di Wu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span> - Theme by <a href="http://alexgaribay.com">Alex Garibay</a>
</p>


        </footer>
      </div>
    </div>
  </div>
  

<script type="text/javascript">
      var disqus_shortname = 'diwu';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
